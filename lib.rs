/* automatically generated by rust-bindgen */

#![allow(non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 25;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type PropertyContainerHandle_t = u64;
pub type PropertyTypeTag_t = u32;
pub const k_nDriverNone: ::std::os::raw::c_uint = 4294967295;
pub const k_unMaxDriverDebugResponseSize: ::std::os::raw::c_uint = 32768;
pub const k_unTrackedDeviceIndex_Hmd: ::std::os::raw::c_uint = 0;
pub const k_unMaxTrackedDeviceCount: ::std::os::raw::c_uint = 16;
pub const k_unTrackedDeviceIndexOther: ::std::os::raw::c_uint = 4294967294;
pub const k_unTrackedDeviceIndexInvalid: ::std::os::raw::c_uint = 4294967295;
pub const k_ulInvalidPropertyContainer: ::std::os::raw::c_ulong = 0;
pub const k_unInvalidPropertyTag: ::std::os::raw::c_uint = 0;
pub const k_unFloatPropertyTag: ::std::os::raw::c_uint = 1;
pub const k_unInt32PropertyTag: ::std::os::raw::c_uint = 2;
pub const k_unUint64PropertyTag: ::std::os::raw::c_uint = 3;
pub const k_unBoolPropertyTag: ::std::os::raw::c_uint = 4;
pub const k_unStringPropertyTag: ::std::os::raw::c_uint = 5;
pub const k_unHmdMatrix34PropertyTag: ::std::os::raw::c_uint = 20;
pub const k_unHmdMatrix44PropertyTag: ::std::os::raw::c_uint = 21;
pub const k_unHmdVector3PropertyTag: ::std::os::raw::c_uint = 22;
pub const k_unHmdVector4PropertyTag: ::std::os::raw::c_uint = 23;
pub const k_unHiddenAreaPropertyTag: ::std::os::raw::c_uint = 30;
pub const k_unOpenVRInternalReserved_Start: ::std::os::raw::c_uint = 1000;
pub const k_unOpenVRInternalReserved_End: ::std::os::raw::c_uint = 10000;
pub const k_unMaxPropertyStringSize: ::std::os::raw::c_uint = 32768;
pub const k_unControllerStateAxisCount: ::std::os::raw::c_uint = 5;
pub const k_ulOverlayHandleInvalid: ::std::os::raw::c_ulong = 0;
pub const k_unScreenshotHandleInvalid: ::std::os::raw::c_uint = 0;
pub const IVRSystem_Version: &'static [u8; 14usize] = b"IVRSystem_016\x00";
pub const IVRExtendedDisplay_Version: &'static [u8; 23usize] =
    b"IVRExtendedDisplay_001\x00";
pub const IVRTrackedCamera_Version: &'static [u8; 21usize] =
    b"IVRTrackedCamera_003\x00";
pub const k_unMaxApplicationKeyLength: ::std::os::raw::c_uint = 128;
pub const k_pch_MimeType_HomeApp: &'static [u8; 8usize] = b"vr/home\x00";
pub const k_pch_MimeType_GameTheater: &'static [u8; 16usize] =
    b"vr/game_theater\x00";
pub const IVRApplications_Version: &'static [u8; 20usize] =
    b"IVRApplications_006\x00";
pub const IVRChaperone_Version: &'static [u8; 17usize] =
    b"IVRChaperone_003\x00";
pub const IVRChaperoneSetup_Version: &'static [u8; 22usize] =
    b"IVRChaperoneSetup_005\x00";
pub const IVRCompositor_Version: &'static [u8; 18usize] =
    b"IVRCompositor_020\x00";
pub const k_unVROverlayMaxKeyLength: ::std::os::raw::c_uint = 128;
pub const k_unVROverlayMaxNameLength: ::std::os::raw::c_uint = 128;
pub const k_unMaxOverlayCount: ::std::os::raw::c_uint = 64;
pub const k_unMaxOverlayIntersectionMaskPrimitivesCount:
          ::std::os::raw::c_uint =
    32;
pub const IVROverlay_Version: &'static [u8; 15usize] = b"IVROverlay_016\x00";
pub const k_pch_Controller_Component_GDC2015: &'static [u8; 8usize] =
    b"gdc2015\x00";
pub const k_pch_Controller_Component_Base: &'static [u8; 5usize] =
    b"base\x00";
pub const k_pch_Controller_Component_Tip: &'static [u8; 4usize] = b"tip\x00";
pub const k_pch_Controller_Component_HandGrip: &'static [u8; 9usize] =
    b"handgrip\x00";
pub const k_pch_Controller_Component_Status: &'static [u8; 7usize] =
    b"status\x00";
pub const IVRRenderModels_Version: &'static [u8; 20usize] =
    b"IVRRenderModels_005\x00";
pub const k_unNotificationTextMaxSize: ::std::os::raw::c_uint = 256;
pub const IVRNotifications_Version: &'static [u8; 21usize] =
    b"IVRNotifications_002\x00";
pub const k_unMaxSettingsKeyLength: ::std::os::raw::c_uint = 128;
pub const IVRSettings_Version: &'static [u8; 16usize] =
    b"IVRSettings_002\x00";
pub const k_pch_SteamVR_Section: &'static [u8; 8usize] = b"steamvr\x00";
pub const k_pch_SteamVR_RequireHmd_String: &'static [u8; 11usize] =
    b"requireHmd\x00";
pub const k_pch_SteamVR_ForcedDriverKey_String: &'static [u8; 13usize] =
    b"forcedDriver\x00";
pub const k_pch_SteamVR_ForcedHmdKey_String: &'static [u8; 10usize] =
    b"forcedHmd\x00";
pub const k_pch_SteamVR_DisplayDebug_Bool: &'static [u8; 13usize] =
    b"displayDebug\x00";
pub const k_pch_SteamVR_DebugProcessPipe_String: &'static [u8; 17usize] =
    b"debugProcessPipe\x00";
pub const k_pch_SteamVR_DisplayDebugX_Int32: &'static [u8; 14usize] =
    b"displayDebugX\x00";
pub const k_pch_SteamVR_DisplayDebugY_Int32: &'static [u8; 14usize] =
    b"displayDebugY\x00";
pub const k_pch_SteamVR_SendSystemButtonToAllApps_Bool: &'static [u8; 26usize]
          =
    b"sendSystemButtonToAllApps\x00";
pub const k_pch_SteamVR_LogLevel_Int32: &'static [u8; 9usize] =
    b"loglevel\x00";
pub const k_pch_SteamVR_IPD_Float: &'static [u8; 4usize] = b"ipd\x00";
pub const k_pch_SteamVR_Background_String: &'static [u8; 11usize] =
    b"background\x00";
pub const k_pch_SteamVR_BackgroundUseDomeProjection_Bool:
          &'static [u8; 28usize] =
    b"backgroundUseDomeProjection\x00";
pub const k_pch_SteamVR_BackgroundCameraHeight_Float: &'static [u8; 23usize] =
    b"backgroundCameraHeight\x00";
pub const k_pch_SteamVR_BackgroundDomeRadius_Float: &'static [u8; 21usize] =
    b"backgroundDomeRadius\x00";
pub const k_pch_SteamVR_GridColor_String: &'static [u8; 10usize] =
    b"gridColor\x00";
pub const k_pch_SteamVR_PlayAreaColor_String: &'static [u8; 14usize] =
    b"playAreaColor\x00";
pub const k_pch_SteamVR_ShowStage_Bool: &'static [u8; 10usize] =
    b"showStage\x00";
pub const k_pch_SteamVR_ActivateMultipleDrivers_Bool: &'static [u8; 24usize] =
    b"activateMultipleDrivers\x00";
pub const k_pch_SteamVR_DirectMode_Bool: &'static [u8; 11usize] =
    b"directMode\x00";
pub const k_pch_SteamVR_DirectModeEdidVid_Int32: &'static [u8; 18usize] =
    b"directModeEdidVid\x00";
pub const k_pch_SteamVR_DirectModeEdidPid_Int32: &'static [u8; 18usize] =
    b"directModeEdidPid\x00";
pub const k_pch_SteamVR_UsingSpeakers_Bool: &'static [u8; 14usize] =
    b"usingSpeakers\x00";
pub const k_pch_SteamVR_SpeakersForwardYawOffsetDegrees_Float:
          &'static [u8; 32usize] =
    b"speakersForwardYawOffsetDegrees\x00";
pub const k_pch_SteamVR_BaseStationPowerManagement_Bool:
          &'static [u8; 27usize] =
    b"basestationPowerManagement\x00";
pub const k_pch_SteamVR_NeverKillProcesses_Bool: &'static [u8; 19usize] =
    b"neverKillProcesses\x00";
pub const k_pch_SteamVR_SupersampleScale_Float: &'static [u8; 17usize] =
    b"supersampleScale\x00";
pub const k_pch_SteamVR_AllowAsyncReprojection_Bool: &'static [u8; 23usize] =
    b"allowAsyncReprojection\x00";
pub const k_pch_SteamVR_AllowReprojection_Bool: &'static [u8; 29usize] =
    b"allowInterleavedReprojection\x00";
pub const k_pch_SteamVR_ForceReprojection_Bool: &'static [u8; 18usize] =
    b"forceReprojection\x00";
pub const k_pch_SteamVR_ForceFadeOnBadTracking_Bool: &'static [u8; 23usize] =
    b"forceFadeOnBadTracking\x00";
pub const k_pch_SteamVR_DefaultMirrorView_Int32: &'static [u8; 18usize] =
    b"defaultMirrorView\x00";
pub const k_pch_SteamVR_ShowMirrorView_Bool: &'static [u8; 15usize] =
    b"showMirrorView\x00";
pub const k_pch_SteamVR_MirrorViewGeometry_String: &'static [u8; 19usize] =
    b"mirrorViewGeometry\x00";
pub const k_pch_SteamVR_StartMonitorFromAppLaunch: &'static [u8; 26usize] =
    b"startMonitorFromAppLaunch\x00";
pub const k_pch_SteamVR_StartCompositorFromAppLaunch_Bool:
          &'static [u8; 29usize] =
    b"startCompositorFromAppLaunch\x00";
pub const k_pch_SteamVR_StartDashboardFromAppLaunch_Bool:
          &'static [u8; 28usize] =
    b"startDashboardFromAppLaunch\x00";
pub const k_pch_SteamVR_StartOverlayAppsFromDashboard_Bool:
          &'static [u8; 30usize] =
    b"startOverlayAppsFromDashboard\x00";
pub const k_pch_SteamVR_EnableHomeApp: &'static [u8; 14usize] =
    b"enableHomeApp\x00";
pub const k_pch_SteamVR_CycleBackgroundImageTimeSec_Int32:
          &'static [u8; 28usize] =
    b"CycleBackgroundImageTimeSec\x00";
pub const k_pch_SteamVR_RetailDemo_Bool: &'static [u8; 11usize] =
    b"retailDemo\x00";
pub const k_pch_SteamVR_IpdOffset_Float: &'static [u8; 10usize] =
    b"ipdOffset\x00";
pub const k_pch_SteamVR_AllowSupersampleFiltering_Bool: &'static [u8; 26usize]
          =
    b"allowSupersampleFiltering\x00";
pub const k_pch_Lighthouse_Section: &'static [u8; 18usize] =
    b"driver_lighthouse\x00";
pub const k_pch_Lighthouse_DisableIMU_Bool: &'static [u8; 11usize] =
    b"disableimu\x00";
pub const k_pch_Lighthouse_UseDisambiguation_String: &'static [u8; 18usize] =
    b"usedisambiguation\x00";
pub const k_pch_Lighthouse_DisambiguationDebug_Int32: &'static [u8; 20usize] =
    b"disambiguationdebug\x00";
pub const k_pch_Lighthouse_PrimaryBasestation_Int32: &'static [u8; 19usize] =
    b"primarybasestation\x00";
pub const k_pch_Lighthouse_DBHistory_Bool: &'static [u8; 10usize] =
    b"dbhistory\x00";
pub const k_pch_Null_Section: &'static [u8; 12usize] = b"driver_null\x00";
pub const k_pch_Null_SerialNumber_String: &'static [u8; 13usize] =
    b"serialNumber\x00";
pub const k_pch_Null_ModelNumber_String: &'static [u8; 12usize] =
    b"modelNumber\x00";
pub const k_pch_Null_WindowX_Int32: &'static [u8; 8usize] = b"windowX\x00";
pub const k_pch_Null_WindowY_Int32: &'static [u8; 8usize] = b"windowY\x00";
pub const k_pch_Null_WindowWidth_Int32: &'static [u8; 12usize] =
    b"windowWidth\x00";
pub const k_pch_Null_WindowHeight_Int32: &'static [u8; 13usize] =
    b"windowHeight\x00";
pub const k_pch_Null_RenderWidth_Int32: &'static [u8; 12usize] =
    b"renderWidth\x00";
pub const k_pch_Null_RenderHeight_Int32: &'static [u8; 13usize] =
    b"renderHeight\x00";
pub const k_pch_Null_SecondsFromVsyncToPhotons_Float: &'static [u8; 26usize] =
    b"secondsFromVsyncToPhotons\x00";
pub const k_pch_Null_DisplayFrequency_Float: &'static [u8; 17usize] =
    b"displayFrequency\x00";
pub const k_pch_UserInterface_Section: &'static [u8; 14usize] =
    b"userinterface\x00";
pub const k_pch_UserInterface_StatusAlwaysOnTop_Bool: &'static [u8; 18usize] =
    b"StatusAlwaysOnTop\x00";
pub const k_pch_UserInterface_MinimizeToTray_Bool: &'static [u8; 15usize] =
    b"MinimizeToTray\x00";
pub const k_pch_UserInterface_Screenshots_Bool: &'static [u8; 12usize] =
    b"screenshots\x00";
pub const k_pch_UserInterface_ScreenshotType_Int: &'static [u8; 15usize] =
    b"screenshotType\x00";
pub const k_pch_Notifications_Section: &'static [u8; 14usize] =
    b"notifications\x00";
pub const k_pch_Notifications_DoNotDisturb_Bool: &'static [u8; 13usize] =
    b"DoNotDisturb\x00";
pub const k_pch_Keyboard_Section: &'static [u8; 9usize] = b"keyboard\x00";
pub const k_pch_Keyboard_TutorialCompletions: &'static [u8; 20usize] =
    b"TutorialCompletions\x00";
pub const k_pch_Keyboard_ScaleX: &'static [u8; 7usize] = b"ScaleX\x00";
pub const k_pch_Keyboard_ScaleY: &'static [u8; 7usize] = b"ScaleY\x00";
pub const k_pch_Keyboard_OffsetLeftX: &'static [u8; 12usize] =
    b"OffsetLeftX\x00";
pub const k_pch_Keyboard_OffsetRightX: &'static [u8; 13usize] =
    b"OffsetRightX\x00";
pub const k_pch_Keyboard_OffsetY: &'static [u8; 8usize] = b"OffsetY\x00";
pub const k_pch_Keyboard_Smoothing: &'static [u8; 10usize] = b"Smoothing\x00";
pub const k_pch_Perf_Section: &'static [u8; 10usize] = b"perfcheck\x00";
pub const k_pch_Perf_HeuristicActive_Bool: &'static [u8; 16usize] =
    b"heuristicActive\x00";
pub const k_pch_Perf_NotifyInHMD_Bool: &'static [u8; 10usize] =
    b"warnInHMD\x00";
pub const k_pch_Perf_NotifyOnlyOnce_Bool: &'static [u8; 13usize] =
    b"warnOnlyOnce\x00";
pub const k_pch_Perf_AllowTimingStore_Bool: &'static [u8; 17usize] =
    b"allowTimingStore\x00";
pub const k_pch_Perf_SaveTimingsOnExit_Bool: &'static [u8; 18usize] =
    b"saveTimingsOnExit\x00";
pub const k_pch_Perf_TestData_Float: &'static [u8; 13usize] =
    b"perfTestData\x00";
pub const k_pch_Perf_LinuxGPUProfiling_Bool: &'static [u8; 18usize] =
    b"linuxGPUProfiling\x00";
pub const k_pch_CollisionBounds_Section: &'static [u8; 16usize] =
    b"collisionBounds\x00";
pub const k_pch_CollisionBounds_Style_Int32: &'static [u8; 21usize] =
    b"CollisionBoundsStyle\x00";
pub const k_pch_CollisionBounds_GroundPerimeterOn_Bool: &'static [u8; 33usize]
          =
    b"CollisionBoundsGroundPerimeterOn\x00";
pub const k_pch_CollisionBounds_CenterMarkerOn_Bool: &'static [u8; 30usize] =
    b"CollisionBoundsCenterMarkerOn\x00";
pub const k_pch_CollisionBounds_PlaySpaceOn_Bool: &'static [u8; 27usize] =
    b"CollisionBoundsPlaySpaceOn\x00";
pub const k_pch_CollisionBounds_FadeDistance_Float: &'static [u8; 28usize] =
    b"CollisionBoundsFadeDistance\x00";
pub const k_pch_CollisionBounds_ColorGammaR_Int32: &'static [u8; 27usize] =
    b"CollisionBoundsColorGammaR\x00";
pub const k_pch_CollisionBounds_ColorGammaG_Int32: &'static [u8; 27usize] =
    b"CollisionBoundsColorGammaG\x00";
pub const k_pch_CollisionBounds_ColorGammaB_Int32: &'static [u8; 27usize] =
    b"CollisionBoundsColorGammaB\x00";
pub const k_pch_CollisionBounds_ColorGammaA_Int32: &'static [u8; 27usize] =
    b"CollisionBoundsColorGammaA\x00";
pub const k_pch_Camera_Section: &'static [u8; 7usize] = b"camera\x00";
pub const k_pch_Camera_EnableCamera_Bool: &'static [u8; 13usize] =
    b"enableCamera\x00";
pub const k_pch_Camera_EnableCameraInDashboard_Bool: &'static [u8; 24usize] =
    b"enableCameraInDashboard\x00";
pub const k_pch_Camera_EnableCameraForCollisionBounds_Bool:
          &'static [u8; 31usize] =
    b"enableCameraForCollisionBounds\x00";
pub const k_pch_Camera_EnableCameraForRoomView_Bool: &'static [u8; 24usize] =
    b"enableCameraForRoomView\x00";
pub const k_pch_Camera_BoundsColorGammaR_Int32: &'static [u8; 24usize] =
    b"cameraBoundsColorGammaR\x00";
pub const k_pch_Camera_BoundsColorGammaG_Int32: &'static [u8; 24usize] =
    b"cameraBoundsColorGammaG\x00";
pub const k_pch_Camera_BoundsColorGammaB_Int32: &'static [u8; 24usize] =
    b"cameraBoundsColorGammaB\x00";
pub const k_pch_Camera_BoundsColorGammaA_Int32: &'static [u8; 24usize] =
    b"cameraBoundsColorGammaA\x00";
pub const k_pch_Camera_BoundsStrength_Int32: &'static [u8; 21usize] =
    b"cameraBoundsStrength\x00";
pub const k_pch_audio_Section: &'static [u8; 6usize] = b"audio\x00";
pub const k_pch_audio_OnPlaybackDevice_String: &'static [u8; 17usize] =
    b"onPlaybackDevice\x00";
pub const k_pch_audio_OnRecordDevice_String: &'static [u8; 15usize] =
    b"onRecordDevice\x00";
pub const k_pch_audio_OnPlaybackMirrorDevice_String: &'static [u8; 23usize] =
    b"onPlaybackMirrorDevice\x00";
pub const k_pch_audio_OffPlaybackDevice_String: &'static [u8; 18usize] =
    b"offPlaybackDevice\x00";
pub const k_pch_audio_OffRecordDevice_String: &'static [u8; 16usize] =
    b"offRecordDevice\x00";
pub const k_pch_audio_VIVEHDMIGain: &'static [u8; 13usize] =
    b"viveHDMIGain\x00";
pub const k_pch_Power_Section: &'static [u8; 6usize] = b"power\x00";
pub const k_pch_Power_PowerOffOnExit_Bool: &'static [u8; 15usize] =
    b"powerOffOnExit\x00";
pub const k_pch_Power_TurnOffScreensTimeout_Float: &'static [u8; 22usize] =
    b"turnOffScreensTimeout\x00";
pub const k_pch_Power_TurnOffControllersTimeout_Float: &'static [u8; 26usize]
          =
    b"turnOffControllersTimeout\x00";
pub const k_pch_Power_ReturnToWatchdogTimeout_Float: &'static [u8; 24usize] =
    b"returnToWatchdogTimeout\x00";
pub const k_pch_Power_AutoLaunchSteamVROnButtonPress: &'static [u8; 31usize] =
    b"autoLaunchSteamVROnButtonPress\x00";
pub const k_pch_Dashboard_Section: &'static [u8; 10usize] = b"dashboard\x00";
pub const k_pch_Dashboard_EnableDashboard_Bool: &'static [u8; 16usize] =
    b"enableDashboard\x00";
pub const k_pch_Dashboard_ArcadeMode_Bool: &'static [u8; 11usize] =
    b"arcadeMode\x00";
pub const k_pch_modelskin_Section: &'static [u8; 11usize] = b"modelskins\x00";
pub const k_pch_Driver_Enable_Bool: &'static [u8; 7usize] = b"enable\x00";
pub const IVRScreenshots_Version: &'static [u8; 19usize] =
    b"IVRScreenshots_001\x00";
pub const IVRResources_Version: &'static [u8; 17usize] =
    b"IVRResources_001\x00";
pub const IVRDriverManager_Version: &'static [u8; 21usize] =
    b"IVRDriverManager_001\x00";
pub const EVREye_EVREye_Eye_Left: EVREye = 0;
pub const EVREye_EVREye_Eye_Right: EVREye = 1;
pub type EVREye = ::std::os::raw::c_uint;
pub const ETextureType_ETextureType_TextureType_DirectX: ETextureType = 0;
pub const ETextureType_ETextureType_TextureType_OpenGL: ETextureType = 1;
pub const ETextureType_ETextureType_TextureType_Vulkan: ETextureType = 2;
pub const ETextureType_ETextureType_TextureType_IOSurface: ETextureType = 3;
pub const ETextureType_ETextureType_TextureType_DirectX12: ETextureType = 4;
pub type ETextureType = ::std::os::raw::c_uint;
pub const EColorSpace_EColorSpace_ColorSpace_Auto: EColorSpace = 0;
pub const EColorSpace_EColorSpace_ColorSpace_Gamma: EColorSpace = 1;
pub const EColorSpace_EColorSpace_ColorSpace_Linear: EColorSpace = 2;
pub type EColorSpace = ::std::os::raw::c_uint;
pub const ETrackingResult_ETrackingResult_TrackingResult_Uninitialized:
          ETrackingResult =
    1;
pub const ETrackingResult_ETrackingResult_TrackingResult_Calibrating_InProgress:
          ETrackingResult =
    100;
pub const ETrackingResult_ETrackingResult_TrackingResult_Calibrating_OutOfRange:
          ETrackingResult =
    101;
pub const ETrackingResult_ETrackingResult_TrackingResult_Running_OK:
          ETrackingResult =
    200;
pub const ETrackingResult_ETrackingResult_TrackingResult_Running_OutOfRange:
          ETrackingResult =
    201;
pub type ETrackingResult = ::std::os::raw::c_uint;
pub const ETrackedDeviceClass_ETrackedDeviceClass_TrackedDeviceClass_Invalid:
          ETrackedDeviceClass =
    0;
pub const ETrackedDeviceClass_ETrackedDeviceClass_TrackedDeviceClass_HMD:
          ETrackedDeviceClass =
    1;
pub const ETrackedDeviceClass_ETrackedDeviceClass_TrackedDeviceClass_Controller:
          ETrackedDeviceClass =
    2;
pub const ETrackedDeviceClass_ETrackedDeviceClass_TrackedDeviceClass_GenericTracker:
          ETrackedDeviceClass =
    3;
pub const ETrackedDeviceClass_ETrackedDeviceClass_TrackedDeviceClass_TrackingReference:
          ETrackedDeviceClass =
    4;
pub const ETrackedDeviceClass_ETrackedDeviceClass_TrackedDeviceClass_DisplayRedirect:
          ETrackedDeviceClass =
    5;
pub type ETrackedDeviceClass = ::std::os::raw::c_uint;
pub const ETrackedControllerRole_ETrackedControllerRole_TrackedControllerRole_Invalid:
          ETrackedControllerRole =
    0;
pub const ETrackedControllerRole_ETrackedControllerRole_TrackedControllerRole_LeftHand:
          ETrackedControllerRole =
    1;
pub const ETrackedControllerRole_ETrackedControllerRole_TrackedControllerRole_RightHand:
          ETrackedControllerRole =
    2;
pub type ETrackedControllerRole = ::std::os::raw::c_uint;
pub const ETrackingUniverseOrigin_ETrackingUniverseOrigin_TrackingUniverseSeated:
          ETrackingUniverseOrigin =
    0;
pub const ETrackingUniverseOrigin_ETrackingUniverseOrigin_TrackingUniverseStanding:
          ETrackingUniverseOrigin =
    1;
pub const ETrackingUniverseOrigin_ETrackingUniverseOrigin_TrackingUniverseRawAndUncalibrated:
          ETrackingUniverseOrigin =
    2;
pub type ETrackingUniverseOrigin = ::std::os::raw::c_uint;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Invalid:
          ETrackedDeviceProperty =
    0;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_TrackingSystemName_String:
          ETrackedDeviceProperty =
    1000;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ModelNumber_String:
          ETrackedDeviceProperty =
    1001;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_SerialNumber_String:
          ETrackedDeviceProperty =
    1002;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_RenderModelName_String:
          ETrackedDeviceProperty =
    1003;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_WillDriftInYaw_Bool:
          ETrackedDeviceProperty =
    1004;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ManufacturerName_String:
          ETrackedDeviceProperty =
    1005;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_TrackingFirmwareVersion_String:
          ETrackedDeviceProperty =
    1006;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_HardwareRevision_String:
          ETrackedDeviceProperty =
    1007;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_AllWirelessDongleDescriptions_String:
          ETrackedDeviceProperty =
    1008;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ConnectedWirelessDongle_String:
          ETrackedDeviceProperty =
    1009;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DeviceIsWireless_Bool:
          ETrackedDeviceProperty =
    1010;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DeviceIsCharging_Bool:
          ETrackedDeviceProperty =
    1011;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DeviceBatteryPercentage_Float:
          ETrackedDeviceProperty =
    1012;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_StatusDisplayTransform_Matrix34:
          ETrackedDeviceProperty =
    1013;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Firmware_UpdateAvailable_Bool:
          ETrackedDeviceProperty =
    1014;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Firmware_ManualUpdate_Bool:
          ETrackedDeviceProperty =
    1015;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Firmware_ManualUpdateURL_String:
          ETrackedDeviceProperty =
    1016;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_HardwareRevision_Uint64:
          ETrackedDeviceProperty =
    1017;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_FirmwareVersion_Uint64:
          ETrackedDeviceProperty =
    1018;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_FPGAVersion_Uint64:
          ETrackedDeviceProperty =
    1019;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_VRCVersion_Uint64:
          ETrackedDeviceProperty =
    1020;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_RadioVersion_Uint64:
          ETrackedDeviceProperty =
    1021;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DongleVersion_Uint64:
          ETrackedDeviceProperty =
    1022;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_BlockServerShutdown_Bool:
          ETrackedDeviceProperty =
    1023;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_CanUnifyCoordinateSystemWithHmd_Bool:
          ETrackedDeviceProperty =
    1024;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ContainsProximitySensor_Bool:
          ETrackedDeviceProperty =
    1025;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DeviceProvidesBatteryStatus_Bool:
          ETrackedDeviceProperty =
    1026;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DeviceCanPowerOff_Bool:
          ETrackedDeviceProperty =
    1027;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Firmware_ProgrammingTarget_String:
          ETrackedDeviceProperty =
    1028;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DeviceClass_Int32:
          ETrackedDeviceProperty =
    1029;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_HasCamera_Bool:
          ETrackedDeviceProperty =
    1030;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DriverVersion_String:
          ETrackedDeviceProperty =
    1031;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Firmware_ForceUpdateRequired_Bool:
          ETrackedDeviceProperty =
    1032;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ViveSystemButtonFixRequired_Bool:
          ETrackedDeviceProperty =
    1033;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ParentDriver_Uint64:
          ETrackedDeviceProperty =
    1034;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ResourceRoot_String:
          ETrackedDeviceProperty =
    1035;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ReportsTimeSinceVSync_Bool:
          ETrackedDeviceProperty =
    2000;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_SecondsFromVsyncToPhotons_Float:
          ETrackedDeviceProperty =
    2001;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayFrequency_Float:
          ETrackedDeviceProperty =
    2002;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_UserIpdMeters_Float:
          ETrackedDeviceProperty =
    2003;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_CurrentUniverseId_Uint64:
          ETrackedDeviceProperty =
    2004;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_PreviousUniverseId_Uint64:
          ETrackedDeviceProperty =
    2005;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayFirmwareVersion_Uint64:
          ETrackedDeviceProperty =
    2006;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_IsOnDesktop_Bool:
          ETrackedDeviceProperty =
    2007;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayMCType_Int32:
          ETrackedDeviceProperty =
    2008;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayMCOffset_Float:
          ETrackedDeviceProperty =
    2009;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayMCScale_Float:
          ETrackedDeviceProperty =
    2010;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_EdidVendorID_Int32:
          ETrackedDeviceProperty =
    2011;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayMCImageLeft_String:
          ETrackedDeviceProperty =
    2012;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayMCImageRight_String:
          ETrackedDeviceProperty =
    2013;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayGCBlackClamp_Float:
          ETrackedDeviceProperty =
    2014;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_EdidProductID_Int32:
          ETrackedDeviceProperty =
    2015;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_CameraToHeadTransform_Matrix34:
          ETrackedDeviceProperty =
    2016;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayGCType_Int32:
          ETrackedDeviceProperty =
    2017;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayGCOffset_Float:
          ETrackedDeviceProperty =
    2018;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayGCScale_Float:
          ETrackedDeviceProperty =
    2019;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayGCPrescale_Float:
          ETrackedDeviceProperty =
    2020;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayGCImage_String:
          ETrackedDeviceProperty =
    2021;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_LensCenterLeftU_Float:
          ETrackedDeviceProperty =
    2022;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_LensCenterLeftV_Float:
          ETrackedDeviceProperty =
    2023;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_LensCenterRightU_Float:
          ETrackedDeviceProperty =
    2024;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_LensCenterRightV_Float:
          ETrackedDeviceProperty =
    2025;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_UserHeadToEyeDepthMeters_Float:
          ETrackedDeviceProperty =
    2026;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_CameraFirmwareVersion_Uint64:
          ETrackedDeviceProperty =
    2027;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_CameraFirmwareDescription_String:
          ETrackedDeviceProperty =
    2028;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayFPGAVersion_Uint64:
          ETrackedDeviceProperty =
    2029;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayBootloaderVersion_Uint64:
          ETrackedDeviceProperty =
    2030;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayHardwareVersion_Uint64:
          ETrackedDeviceProperty =
    2031;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_AudioFirmwareVersion_Uint64:
          ETrackedDeviceProperty =
    2032;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_CameraCompatibilityMode_Int32:
          ETrackedDeviceProperty =
    2033;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ScreenshotHorizontalFieldOfViewDegrees_Float:
          ETrackedDeviceProperty =
    2034;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ScreenshotVerticalFieldOfViewDegrees_Float:
          ETrackedDeviceProperty =
    2035;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplaySuppressed_Bool:
          ETrackedDeviceProperty =
    2036;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayAllowNightMode_Bool:
          ETrackedDeviceProperty =
    2037;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayMCImageWidth_Int32:
          ETrackedDeviceProperty =
    2038;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayMCImageHeight_Int32:
          ETrackedDeviceProperty =
    2039;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayMCImageNumChannels_Int32:
          ETrackedDeviceProperty =
    2040;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayMCImageData_Binary:
          ETrackedDeviceProperty =
    2041;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_SecondsFromPhotonsToVblank_Float:
          ETrackedDeviceProperty =
    2042;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DriverDirectModeSendsVsyncEvents_Bool:
          ETrackedDeviceProperty =
    2043;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayDebugMode_Bool:
          ETrackedDeviceProperty =
    2044;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_GraphicsAdapterLuid_Uint64:
          ETrackedDeviceProperty =
    2045;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_AttachedDeviceId_String:
          ETrackedDeviceProperty =
    3000;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_SupportedButtons_Uint64:
          ETrackedDeviceProperty =
    3001;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Axis0Type_Int32:
          ETrackedDeviceProperty =
    3002;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Axis1Type_Int32:
          ETrackedDeviceProperty =
    3003;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Axis2Type_Int32:
          ETrackedDeviceProperty =
    3004;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Axis3Type_Int32:
          ETrackedDeviceProperty =
    3005;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_Axis4Type_Int32:
          ETrackedDeviceProperty =
    3006;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ControllerRoleHint_Int32:
          ETrackedDeviceProperty =
    3007;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_FieldOfViewLeftDegrees_Float:
          ETrackedDeviceProperty =
    4000;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_FieldOfViewRightDegrees_Float:
          ETrackedDeviceProperty =
    4001;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_FieldOfViewTopDegrees_Float:
          ETrackedDeviceProperty =
    4002;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_FieldOfViewBottomDegrees_Float:
          ETrackedDeviceProperty =
    4003;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_TrackingRangeMinimumMeters_Float:
          ETrackedDeviceProperty =
    4004;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_TrackingRangeMaximumMeters_Float:
          ETrackedDeviceProperty =
    4005;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_ModeLabel_String:
          ETrackedDeviceProperty =
    4006;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_IconPathName_String:
          ETrackedDeviceProperty =
    5000;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_NamedIconPathDeviceOff_String:
          ETrackedDeviceProperty =
    5001;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_NamedIconPathDeviceSearching_String:
          ETrackedDeviceProperty =
    5002;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_NamedIconPathDeviceSearchingAlert_String:
          ETrackedDeviceProperty =
    5003;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_NamedIconPathDeviceReady_String:
          ETrackedDeviceProperty =
    5004;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_NamedIconPathDeviceReadyAlert_String:
          ETrackedDeviceProperty =
    5005;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_NamedIconPathDeviceNotReady_String:
          ETrackedDeviceProperty =
    5006;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_NamedIconPathDeviceStandby_String:
          ETrackedDeviceProperty =
    5007;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_NamedIconPathDeviceAlertLow_String:
          ETrackedDeviceProperty =
    5008;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayHiddenArea_Binary_Start:
          ETrackedDeviceProperty =
    5100;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_DisplayHiddenArea_Binary_End:
          ETrackedDeviceProperty =
    5150;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_UserConfigPath_String:
          ETrackedDeviceProperty =
    6000;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_InstallPath_String:
          ETrackedDeviceProperty =
    6001;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_HasDisplayComponent_Bool:
          ETrackedDeviceProperty =
    6002;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_HasControllerComponent_Bool:
          ETrackedDeviceProperty =
    6003;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_HasCameraComponent_Bool:
          ETrackedDeviceProperty =
    6004;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_HasDriverDirectModeComponent_Bool:
          ETrackedDeviceProperty =
    6005;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_HasVirtualDisplayComponent_Bool:
          ETrackedDeviceProperty =
    6006;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_VendorSpecific_Reserved_Start:
          ETrackedDeviceProperty =
    10000;
pub const ETrackedDeviceProperty_ETrackedDeviceProperty_Prop_VendorSpecific_Reserved_End:
          ETrackedDeviceProperty =
    10999;
pub type ETrackedDeviceProperty = ::std::os::raw::c_uint;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_Success:
          ETrackedPropertyError =
    0;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_WrongDataType:
          ETrackedPropertyError =
    1;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_WrongDeviceClass:
          ETrackedPropertyError =
    2;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_BufferTooSmall:
          ETrackedPropertyError =
    3;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_UnknownProperty:
          ETrackedPropertyError =
    4;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_InvalidDevice:
          ETrackedPropertyError =
    5;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_CouldNotContactServer:
          ETrackedPropertyError =
    6;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_ValueNotProvidedByDevice:
          ETrackedPropertyError =
    7;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_StringExceedsMaximumLength:
          ETrackedPropertyError =
    8;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_NotYetAvailable:
          ETrackedPropertyError =
    9;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_PermissionDenied:
          ETrackedPropertyError =
    10;
pub const ETrackedPropertyError_ETrackedPropertyError_TrackedProp_InvalidOperation:
          ETrackedPropertyError =
    11;
pub type ETrackedPropertyError = ::std::os::raw::c_uint;
pub const EVRSubmitFlags_EVRSubmitFlags_Submit_Default: EVRSubmitFlags = 0;
pub const EVRSubmitFlags_EVRSubmitFlags_Submit_LensDistortionAlreadyApplied:
          EVRSubmitFlags =
    1;
pub const EVRSubmitFlags_EVRSubmitFlags_Submit_GlRenderBuffer: EVRSubmitFlags
          =
    2;
pub const EVRSubmitFlags_EVRSubmitFlags_Submit_Reserved: EVRSubmitFlags = 4;
pub type EVRSubmitFlags = ::std::os::raw::c_uint;
pub const EVRState_EVRState_VRState_Undefined: EVRState = -1;
pub const EVRState_EVRState_VRState_Off: EVRState = 0;
pub const EVRState_EVRState_VRState_Searching: EVRState = 1;
pub const EVRState_EVRState_VRState_Searching_Alert: EVRState = 2;
pub const EVRState_EVRState_VRState_Ready: EVRState = 3;
pub const EVRState_EVRState_VRState_Ready_Alert: EVRState = 4;
pub const EVRState_EVRState_VRState_NotReady: EVRState = 5;
pub const EVRState_EVRState_VRState_Standby: EVRState = 6;
pub const EVRState_EVRState_VRState_Ready_Alert_Low: EVRState = 7;
pub type EVRState = ::std::os::raw::c_int;
pub const EVREventType_EVREventType_VREvent_None: EVREventType = 0;
pub const EVREventType_EVREventType_VREvent_TrackedDeviceActivated:
          EVREventType =
    100;
pub const EVREventType_EVREventType_VREvent_TrackedDeviceDeactivated:
          EVREventType =
    101;
pub const EVREventType_EVREventType_VREvent_TrackedDeviceUpdated: EVREventType
          =
    102;
pub const EVREventType_EVREventType_VREvent_TrackedDeviceUserInteractionStarted:
          EVREventType =
    103;
pub const EVREventType_EVREventType_VREvent_TrackedDeviceUserInteractionEnded:
          EVREventType =
    104;
pub const EVREventType_EVREventType_VREvent_IpdChanged: EVREventType = 105;
pub const EVREventType_EVREventType_VREvent_EnterStandbyMode: EVREventType =
    106;
pub const EVREventType_EVREventType_VREvent_LeaveStandbyMode: EVREventType =
    107;
pub const EVREventType_EVREventType_VREvent_TrackedDeviceRoleChanged:
          EVREventType =
    108;
pub const EVREventType_EVREventType_VREvent_WatchdogWakeUpRequested:
          EVREventType =
    109;
pub const EVREventType_EVREventType_VREvent_LensDistortionChanged:
          EVREventType =
    110;
pub const EVREventType_EVREventType_VREvent_PropertyChanged: EVREventType =
    111;
pub const EVREventType_EVREventType_VREvent_ButtonPress: EVREventType = 200;
pub const EVREventType_EVREventType_VREvent_ButtonUnpress: EVREventType = 201;
pub const EVREventType_EVREventType_VREvent_ButtonTouch: EVREventType = 202;
pub const EVREventType_EVREventType_VREvent_ButtonUntouch: EVREventType = 203;
pub const EVREventType_EVREventType_VREvent_MouseMove: EVREventType = 300;
pub const EVREventType_EVREventType_VREvent_MouseButtonDown: EVREventType =
    301;
pub const EVREventType_EVREventType_VREvent_MouseButtonUp: EVREventType = 302;
pub const EVREventType_EVREventType_VREvent_FocusEnter: EVREventType = 303;
pub const EVREventType_EVREventType_VREvent_FocusLeave: EVREventType = 304;
pub const EVREventType_EVREventType_VREvent_Scroll: EVREventType = 305;
pub const EVREventType_EVREventType_VREvent_TouchPadMove: EVREventType = 306;
pub const EVREventType_EVREventType_VREvent_OverlayFocusChanged: EVREventType
          =
    307;
pub const EVREventType_EVREventType_VREvent_InputFocusCaptured: EVREventType =
    400;
pub const EVREventType_EVREventType_VREvent_InputFocusReleased: EVREventType =
    401;
pub const EVREventType_EVREventType_VREvent_SceneFocusLost: EVREventType =
    402;
pub const EVREventType_EVREventType_VREvent_SceneFocusGained: EVREventType =
    403;
pub const EVREventType_EVREventType_VREvent_SceneApplicationChanged:
          EVREventType =
    404;
pub const EVREventType_EVREventType_VREvent_SceneFocusChanged: EVREventType =
    405;
pub const EVREventType_EVREventType_VREvent_InputFocusChanged: EVREventType =
    406;
pub const EVREventType_EVREventType_VREvent_SceneApplicationSecondaryRenderingStarted:
          EVREventType =
    407;
pub const EVREventType_EVREventType_VREvent_HideRenderModels: EVREventType =
    410;
pub const EVREventType_EVREventType_VREvent_ShowRenderModels: EVREventType =
    411;
pub const EVREventType_EVREventType_VREvent_OverlayShown: EVREventType = 500;
pub const EVREventType_EVREventType_VREvent_OverlayHidden: EVREventType = 501;
pub const EVREventType_EVREventType_VREvent_DashboardActivated: EVREventType =
    502;
pub const EVREventType_EVREventType_VREvent_DashboardDeactivated: EVREventType
          =
    503;
pub const EVREventType_EVREventType_VREvent_DashboardThumbSelected:
          EVREventType =
    504;
pub const EVREventType_EVREventType_VREvent_DashboardRequested: EVREventType =
    505;
pub const EVREventType_EVREventType_VREvent_ResetDashboard: EVREventType =
    506;
pub const EVREventType_EVREventType_VREvent_RenderToast: EVREventType = 507;
pub const EVREventType_EVREventType_VREvent_ImageLoaded: EVREventType = 508;
pub const EVREventType_EVREventType_VREvent_ShowKeyboard: EVREventType = 509;
pub const EVREventType_EVREventType_VREvent_HideKeyboard: EVREventType = 510;
pub const EVREventType_EVREventType_VREvent_OverlayGamepadFocusGained:
          EVREventType =
    511;
pub const EVREventType_EVREventType_VREvent_OverlayGamepadFocusLost:
          EVREventType =
    512;
pub const EVREventType_EVREventType_VREvent_OverlaySharedTextureChanged:
          EVREventType =
    513;
pub const EVREventType_EVREventType_VREvent_DashboardGuideButtonDown:
          EVREventType =
    514;
pub const EVREventType_EVREventType_VREvent_DashboardGuideButtonUp:
          EVREventType =
    515;
pub const EVREventType_EVREventType_VREvent_ScreenshotTriggered: EVREventType
          =
    516;
pub const EVREventType_EVREventType_VREvent_ImageFailed: EVREventType = 517;
pub const EVREventType_EVREventType_VREvent_DashboardOverlayCreated:
          EVREventType =
    518;
pub const EVREventType_EVREventType_VREvent_RequestScreenshot: EVREventType =
    520;
pub const EVREventType_EVREventType_VREvent_ScreenshotTaken: EVREventType =
    521;
pub const EVREventType_EVREventType_VREvent_ScreenshotFailed: EVREventType =
    522;
pub const EVREventType_EVREventType_VREvent_SubmitScreenshotToDashboard:
          EVREventType =
    523;
pub const EVREventType_EVREventType_VREvent_ScreenshotProgressToDashboard:
          EVREventType =
    524;
pub const EVREventType_EVREventType_VREvent_PrimaryDashboardDeviceChanged:
          EVREventType =
    525;
pub const EVREventType_EVREventType_VREvent_Notification_Shown: EVREventType =
    600;
pub const EVREventType_EVREventType_VREvent_Notification_Hidden: EVREventType
          =
    601;
pub const EVREventType_EVREventType_VREvent_Notification_BeginInteraction:
          EVREventType =
    602;
pub const EVREventType_EVREventType_VREvent_Notification_Destroyed:
          EVREventType =
    603;
pub const EVREventType_EVREventType_VREvent_Quit: EVREventType = 700;
pub const EVREventType_EVREventType_VREvent_ProcessQuit: EVREventType = 701;
pub const EVREventType_EVREventType_VREvent_QuitAborted_UserPrompt:
          EVREventType =
    702;
pub const EVREventType_EVREventType_VREvent_QuitAcknowledged: EVREventType =
    703;
pub const EVREventType_EVREventType_VREvent_DriverRequestedQuit: EVREventType
          =
    704;
pub const EVREventType_EVREventType_VREvent_ChaperoneDataHasChanged:
          EVREventType =
    800;
pub const EVREventType_EVREventType_VREvent_ChaperoneUniverseHasChanged:
          EVREventType =
    801;
pub const EVREventType_EVREventType_VREvent_ChaperoneTempDataHasChanged:
          EVREventType =
    802;
pub const EVREventType_EVREventType_VREvent_ChaperoneSettingsHaveChanged:
          EVREventType =
    803;
pub const EVREventType_EVREventType_VREvent_SeatedZeroPoseReset: EVREventType
          =
    804;
pub const EVREventType_EVREventType_VREvent_AudioSettingsHaveChanged:
          EVREventType =
    820;
pub const EVREventType_EVREventType_VREvent_BackgroundSettingHasChanged:
          EVREventType =
    850;
pub const EVREventType_EVREventType_VREvent_CameraSettingsHaveChanged:
          EVREventType =
    851;
pub const EVREventType_EVREventType_VREvent_ReprojectionSettingHasChanged:
          EVREventType =
    852;
pub const EVREventType_EVREventType_VREvent_ModelSkinSettingsHaveChanged:
          EVREventType =
    853;
pub const EVREventType_EVREventType_VREvent_EnvironmentSettingsHaveChanged:
          EVREventType =
    854;
pub const EVREventType_EVREventType_VREvent_PowerSettingsHaveChanged:
          EVREventType =
    855;
pub const EVREventType_EVREventType_VREvent_EnableHomeAppSettingsHaveChanged:
          EVREventType =
    856;
pub const EVREventType_EVREventType_VREvent_StatusUpdate: EVREventType = 900;
pub const EVREventType_EVREventType_VREvent_MCImageUpdated: EVREventType =
    1000;
pub const EVREventType_EVREventType_VREvent_FirmwareUpdateStarted:
          EVREventType =
    1100;
pub const EVREventType_EVREventType_VREvent_FirmwareUpdateFinished:
          EVREventType =
    1101;
pub const EVREventType_EVREventType_VREvent_KeyboardClosed: EVREventType =
    1200;
pub const EVREventType_EVREventType_VREvent_KeyboardCharInput: EVREventType =
    1201;
pub const EVREventType_EVREventType_VREvent_KeyboardDone: EVREventType = 1202;
pub const EVREventType_EVREventType_VREvent_ApplicationTransitionStarted:
          EVREventType =
    1300;
pub const EVREventType_EVREventType_VREvent_ApplicationTransitionAborted:
          EVREventType =
    1301;
pub const EVREventType_EVREventType_VREvent_ApplicationTransitionNewAppStarted:
          EVREventType =
    1302;
pub const EVREventType_EVREventType_VREvent_ApplicationListUpdated:
          EVREventType =
    1303;
pub const EVREventType_EVREventType_VREvent_ApplicationMimeTypeLoad:
          EVREventType =
    1304;
pub const EVREventType_EVREventType_VREvent_ApplicationTransitionNewAppLaunchComplete:
          EVREventType =
    1305;
pub const EVREventType_EVREventType_VREvent_ProcessConnected: EVREventType =
    1306;
pub const EVREventType_EVREventType_VREvent_ProcessDisconnected: EVREventType
          =
    1307;
pub const EVREventType_EVREventType_VREvent_Compositor_MirrorWindowShown:
          EVREventType =
    1400;
pub const EVREventType_EVREventType_VREvent_Compositor_MirrorWindowHidden:
          EVREventType =
    1401;
pub const EVREventType_EVREventType_VREvent_Compositor_ChaperoneBoundsShown:
          EVREventType =
    1410;
pub const EVREventType_EVREventType_VREvent_Compositor_ChaperoneBoundsHidden:
          EVREventType =
    1411;
pub const EVREventType_EVREventType_VREvent_TrackedCamera_StartVideoStream:
          EVREventType =
    1500;
pub const EVREventType_EVREventType_VREvent_TrackedCamera_StopVideoStream:
          EVREventType =
    1501;
pub const EVREventType_EVREventType_VREvent_TrackedCamera_PauseVideoStream:
          EVREventType =
    1502;
pub const EVREventType_EVREventType_VREvent_TrackedCamera_ResumeVideoStream:
          EVREventType =
    1503;
pub const EVREventType_EVREventType_VREvent_TrackedCamera_EditingSurface:
          EVREventType =
    1550;
pub const EVREventType_EVREventType_VREvent_PerformanceTest_EnableCapture:
          EVREventType =
    1600;
pub const EVREventType_EVREventType_VREvent_PerformanceTest_DisableCapture:
          EVREventType =
    1601;
pub const EVREventType_EVREventType_VREvent_PerformanceTest_FidelityLevel:
          EVREventType =
    1602;
pub const EVREventType_EVREventType_VREvent_MessageOverlay_Closed:
          EVREventType =
    1650;
pub const EVREventType_EVREventType_VREvent_VendorSpecific_Reserved_Start:
          EVREventType =
    10000;
pub const EVREventType_EVREventType_VREvent_VendorSpecific_Reserved_End:
          EVREventType =
    19999;
pub type EVREventType = ::std::os::raw::c_uint;
pub const EDeviceActivityLevel_EDeviceActivityLevel_k_EDeviceActivityLevel_Unknown:
          EDeviceActivityLevel =
    -1;
pub const EDeviceActivityLevel_EDeviceActivityLevel_k_EDeviceActivityLevel_Idle:
          EDeviceActivityLevel =
    0;
pub const EDeviceActivityLevel_EDeviceActivityLevel_k_EDeviceActivityLevel_UserInteraction:
          EDeviceActivityLevel =
    1;
pub const EDeviceActivityLevel_EDeviceActivityLevel_k_EDeviceActivityLevel_UserInteraction_Timeout:
          EDeviceActivityLevel =
    2;
pub const EDeviceActivityLevel_EDeviceActivityLevel_k_EDeviceActivityLevel_Standby:
          EDeviceActivityLevel =
    3;
pub type EDeviceActivityLevel = ::std::os::raw::c_int;
pub const EVRButtonId_EVRButtonId_k_EButton_System: EVRButtonId = 0;
pub const EVRButtonId_EVRButtonId_k_EButton_ApplicationMenu: EVRButtonId = 1;
pub const EVRButtonId_EVRButtonId_k_EButton_Grip: EVRButtonId = 2;
pub const EVRButtonId_EVRButtonId_k_EButton_DPad_Left: EVRButtonId = 3;
pub const EVRButtonId_EVRButtonId_k_EButton_DPad_Up: EVRButtonId = 4;
pub const EVRButtonId_EVRButtonId_k_EButton_DPad_Right: EVRButtonId = 5;
pub const EVRButtonId_EVRButtonId_k_EButton_DPad_Down: EVRButtonId = 6;
pub const EVRButtonId_EVRButtonId_k_EButton_A: EVRButtonId = 7;
pub const EVRButtonId_EVRButtonId_k_EButton_ProximitySensor: EVRButtonId = 31;
pub const EVRButtonId_EVRButtonId_k_EButton_Axis0: EVRButtonId = 32;
pub const EVRButtonId_EVRButtonId_k_EButton_Axis1: EVRButtonId = 33;
pub const EVRButtonId_EVRButtonId_k_EButton_Axis2: EVRButtonId = 34;
pub const EVRButtonId_EVRButtonId_k_EButton_Axis3: EVRButtonId = 35;
pub const EVRButtonId_EVRButtonId_k_EButton_Axis4: EVRButtonId = 36;
pub const EVRButtonId_EVRButtonId_k_EButton_SteamVR_Touchpad: EVRButtonId =
    32;
pub const EVRButtonId_EVRButtonId_k_EButton_SteamVR_Trigger: EVRButtonId = 33;
pub const EVRButtonId_EVRButtonId_k_EButton_Dashboard_Back: EVRButtonId = 2;
pub const EVRButtonId_EVRButtonId_k_EButton_Max: EVRButtonId = 64;
pub type EVRButtonId = ::std::os::raw::c_uint;
pub const EVRMouseButton_EVRMouseButton_VRMouseButton_Left: EVRMouseButton =
    1;
pub const EVRMouseButton_EVRMouseButton_VRMouseButton_Right: EVRMouseButton =
    2;
pub const EVRMouseButton_EVRMouseButton_VRMouseButton_Middle: EVRMouseButton =
    4;
pub type EVRMouseButton = ::std::os::raw::c_uint;
pub const EHiddenAreaMeshType_EHiddenAreaMeshType_k_eHiddenAreaMesh_Standard:
          EHiddenAreaMeshType =
    0;
pub const EHiddenAreaMeshType_EHiddenAreaMeshType_k_eHiddenAreaMesh_Inverse:
          EHiddenAreaMeshType =
    1;
pub const EHiddenAreaMeshType_EHiddenAreaMeshType_k_eHiddenAreaMesh_LineLoop:
          EHiddenAreaMeshType =
    2;
pub const EHiddenAreaMeshType_EHiddenAreaMeshType_k_eHiddenAreaMesh_Max:
          EHiddenAreaMeshType =
    3;
pub type EHiddenAreaMeshType = ::std::os::raw::c_uint;
pub const EVRControllerAxisType_EVRControllerAxisType_k_eControllerAxis_None:
          EVRControllerAxisType =
    0;
pub const EVRControllerAxisType_EVRControllerAxisType_k_eControllerAxis_TrackPad:
          EVRControllerAxisType =
    1;
pub const EVRControllerAxisType_EVRControllerAxisType_k_eControllerAxis_Joystick:
          EVRControllerAxisType =
    2;
pub const EVRControllerAxisType_EVRControllerAxisType_k_eControllerAxis_Trigger:
          EVRControllerAxisType =
    3;
pub type EVRControllerAxisType = ::std::os::raw::c_uint;
pub const EVRControllerEventOutputType_EVRControllerEventOutputType_ControllerEventOutput_OSEvents:
          EVRControllerEventOutputType =
    0;
pub const EVRControllerEventOutputType_EVRControllerEventOutputType_ControllerEventOutput_VREvents:
          EVRControllerEventOutputType =
    1;
pub type EVRControllerEventOutputType = ::std::os::raw::c_uint;
pub const ECollisionBoundsStyle_ECollisionBoundsStyle_COLLISION_BOUNDS_STYLE_BEGINNER:
          ECollisionBoundsStyle =
    0;
pub const ECollisionBoundsStyle_ECollisionBoundsStyle_COLLISION_BOUNDS_STYLE_INTERMEDIATE:
          ECollisionBoundsStyle =
    1;
pub const ECollisionBoundsStyle_ECollisionBoundsStyle_COLLISION_BOUNDS_STYLE_SQUARES:
          ECollisionBoundsStyle =
    2;
pub const ECollisionBoundsStyle_ECollisionBoundsStyle_COLLISION_BOUNDS_STYLE_ADVANCED:
          ECollisionBoundsStyle =
    3;
pub const ECollisionBoundsStyle_ECollisionBoundsStyle_COLLISION_BOUNDS_STYLE_NONE:
          ECollisionBoundsStyle =
    4;
pub const ECollisionBoundsStyle_ECollisionBoundsStyle_COLLISION_BOUNDS_STYLE_COUNT:
          ECollisionBoundsStyle =
    5;
pub type ECollisionBoundsStyle = ::std::os::raw::c_uint;
pub const EVROverlayError_EVROverlayError_VROverlayError_None: EVROverlayError
          =
    0;
pub const EVROverlayError_EVROverlayError_VROverlayError_UnknownOverlay:
          EVROverlayError =
    10;
pub const EVROverlayError_EVROverlayError_VROverlayError_InvalidHandle:
          EVROverlayError =
    11;
pub const EVROverlayError_EVROverlayError_VROverlayError_PermissionDenied:
          EVROverlayError =
    12;
pub const EVROverlayError_EVROverlayError_VROverlayError_OverlayLimitExceeded:
          EVROverlayError =
    13;
pub const EVROverlayError_EVROverlayError_VROverlayError_WrongVisibilityType:
          EVROverlayError =
    14;
pub const EVROverlayError_EVROverlayError_VROverlayError_KeyTooLong:
          EVROverlayError =
    15;
pub const EVROverlayError_EVROverlayError_VROverlayError_NameTooLong:
          EVROverlayError =
    16;
pub const EVROverlayError_EVROverlayError_VROverlayError_KeyInUse:
          EVROverlayError =
    17;
pub const EVROverlayError_EVROverlayError_VROverlayError_WrongTransformType:
          EVROverlayError =
    18;
pub const EVROverlayError_EVROverlayError_VROverlayError_InvalidTrackedDevice:
          EVROverlayError =
    19;
pub const EVROverlayError_EVROverlayError_VROverlayError_InvalidParameter:
          EVROverlayError =
    20;
pub const EVROverlayError_EVROverlayError_VROverlayError_ThumbnailCantBeDestroyed:
          EVROverlayError =
    21;
pub const EVROverlayError_EVROverlayError_VROverlayError_ArrayTooSmall:
          EVROverlayError =
    22;
pub const EVROverlayError_EVROverlayError_VROverlayError_RequestFailed:
          EVROverlayError =
    23;
pub const EVROverlayError_EVROverlayError_VROverlayError_InvalidTexture:
          EVROverlayError =
    24;
pub const EVROverlayError_EVROverlayError_VROverlayError_UnableToLoadFile:
          EVROverlayError =
    25;
pub const EVROverlayError_EVROverlayError_VROverlayError_KeyboardAlreadyInUse:
          EVROverlayError =
    26;
pub const EVROverlayError_EVROverlayError_VROverlayError_NoNeighbor:
          EVROverlayError =
    27;
pub const EVROverlayError_EVROverlayError_VROverlayError_TooManyMaskPrimitives:
          EVROverlayError =
    29;
pub const EVROverlayError_EVROverlayError_VROverlayError_BadMaskPrimitive:
          EVROverlayError =
    30;
pub type EVROverlayError = ::std::os::raw::c_uint;
pub const EVRApplicationType_EVRApplicationType_VRApplication_Other:
          EVRApplicationType =
    0;
pub const EVRApplicationType_EVRApplicationType_VRApplication_Scene:
          EVRApplicationType =
    1;
pub const EVRApplicationType_EVRApplicationType_VRApplication_Overlay:
          EVRApplicationType =
    2;
pub const EVRApplicationType_EVRApplicationType_VRApplication_Background:
          EVRApplicationType =
    3;
pub const EVRApplicationType_EVRApplicationType_VRApplication_Utility:
          EVRApplicationType =
    4;
pub const EVRApplicationType_EVRApplicationType_VRApplication_VRMonitor:
          EVRApplicationType =
    5;
pub const EVRApplicationType_EVRApplicationType_VRApplication_SteamWatchdog:
          EVRApplicationType =
    6;
pub const EVRApplicationType_EVRApplicationType_VRApplication_Bootstrapper:
          EVRApplicationType =
    7;
pub const EVRApplicationType_EVRApplicationType_VRApplication_Max:
          EVRApplicationType =
    8;
pub type EVRApplicationType = ::std::os::raw::c_uint;
pub const EVRFirmwareError_EVRFirmwareError_VRFirmwareError_None:
          EVRFirmwareError =
    0;
pub const EVRFirmwareError_EVRFirmwareError_VRFirmwareError_Success:
          EVRFirmwareError =
    1;
pub const EVRFirmwareError_EVRFirmwareError_VRFirmwareError_Fail:
          EVRFirmwareError =
    2;
pub type EVRFirmwareError = ::std::os::raw::c_uint;
pub const EVRNotificationError_EVRNotificationError_VRNotificationError_OK:
          EVRNotificationError =
    0;
pub const EVRNotificationError_EVRNotificationError_VRNotificationError_InvalidNotificationId:
          EVRNotificationError =
    100;
pub const EVRNotificationError_EVRNotificationError_VRNotificationError_NotificationQueueFull:
          EVRNotificationError =
    101;
pub const EVRNotificationError_EVRNotificationError_VRNotificationError_InvalidOverlayHandle:
          EVRNotificationError =
    102;
pub const EVRNotificationError_EVRNotificationError_VRNotificationError_SystemWithUserValueAlreadyExists:
          EVRNotificationError =
    103;
pub type EVRNotificationError = ::std::os::raw::c_uint;
pub const EVRInitError_EVRInitError_VRInitError_None: EVRInitError = 0;
pub const EVRInitError_EVRInitError_VRInitError_Unknown: EVRInitError = 1;
pub const EVRInitError_EVRInitError_VRInitError_Init_InstallationNotFound:
          EVRInitError =
    100;
pub const EVRInitError_EVRInitError_VRInitError_Init_InstallationCorrupt:
          EVRInitError =
    101;
pub const EVRInitError_EVRInitError_VRInitError_Init_VRClientDLLNotFound:
          EVRInitError =
    102;
pub const EVRInitError_EVRInitError_VRInitError_Init_FileNotFound:
          EVRInitError =
    103;
pub const EVRInitError_EVRInitError_VRInitError_Init_FactoryNotFound:
          EVRInitError =
    104;
pub const EVRInitError_EVRInitError_VRInitError_Init_InterfaceNotFound:
          EVRInitError =
    105;
pub const EVRInitError_EVRInitError_VRInitError_Init_InvalidInterface:
          EVRInitError =
    106;
pub const EVRInitError_EVRInitError_VRInitError_Init_UserConfigDirectoryInvalid:
          EVRInitError =
    107;
pub const EVRInitError_EVRInitError_VRInitError_Init_HmdNotFound: EVRInitError
          =
    108;
pub const EVRInitError_EVRInitError_VRInitError_Init_NotInitialized:
          EVRInitError =
    109;
pub const EVRInitError_EVRInitError_VRInitError_Init_PathRegistryNotFound:
          EVRInitError =
    110;
pub const EVRInitError_EVRInitError_VRInitError_Init_NoConfigPath:
          EVRInitError =
    111;
pub const EVRInitError_EVRInitError_VRInitError_Init_NoLogPath: EVRInitError =
    112;
pub const EVRInitError_EVRInitError_VRInitError_Init_PathRegistryNotWritable:
          EVRInitError =
    113;
pub const EVRInitError_EVRInitError_VRInitError_Init_AppInfoInitFailed:
          EVRInitError =
    114;
pub const EVRInitError_EVRInitError_VRInitError_Init_Retry: EVRInitError =
    115;
pub const EVRInitError_EVRInitError_VRInitError_Init_InitCanceledByUser:
          EVRInitError =
    116;
pub const EVRInitError_EVRInitError_VRInitError_Init_AnotherAppLaunching:
          EVRInitError =
    117;
pub const EVRInitError_EVRInitError_VRInitError_Init_SettingsInitFailed:
          EVRInitError =
    118;
pub const EVRInitError_EVRInitError_VRInitError_Init_ShuttingDown:
          EVRInitError =
    119;
pub const EVRInitError_EVRInitError_VRInitError_Init_TooManyObjects:
          EVRInitError =
    120;
pub const EVRInitError_EVRInitError_VRInitError_Init_NoServerForBackgroundApp:
          EVRInitError =
    121;
pub const EVRInitError_EVRInitError_VRInitError_Init_NotSupportedWithCompositor:
          EVRInitError =
    122;
pub const EVRInitError_EVRInitError_VRInitError_Init_NotAvailableToUtilityApps:
          EVRInitError =
    123;
pub const EVRInitError_EVRInitError_VRInitError_Init_Internal: EVRInitError =
    124;
pub const EVRInitError_EVRInitError_VRInitError_Init_HmdDriverIdIsNone:
          EVRInitError =
    125;
pub const EVRInitError_EVRInitError_VRInitError_Init_HmdNotFoundPresenceFailed:
          EVRInitError =
    126;
pub const EVRInitError_EVRInitError_VRInitError_Init_VRMonitorNotFound:
          EVRInitError =
    127;
pub const EVRInitError_EVRInitError_VRInitError_Init_VRMonitorStartupFailed:
          EVRInitError =
    128;
pub const EVRInitError_EVRInitError_VRInitError_Init_LowPowerWatchdogNotSupported:
          EVRInitError =
    129;
pub const EVRInitError_EVRInitError_VRInitError_Init_InvalidApplicationType:
          EVRInitError =
    130;
pub const EVRInitError_EVRInitError_VRInitError_Init_NotAvailableToWatchdogApps:
          EVRInitError =
    131;
pub const EVRInitError_EVRInitError_VRInitError_Init_WatchdogDisabledInSettings:
          EVRInitError =
    132;
pub const EVRInitError_EVRInitError_VRInitError_Init_VRDashboardNotFound:
          EVRInitError =
    133;
pub const EVRInitError_EVRInitError_VRInitError_Init_VRDashboardStartupFailed:
          EVRInitError =
    134;
pub const EVRInitError_EVRInitError_VRInitError_Init_VRHomeNotFound:
          EVRInitError =
    135;
pub const EVRInitError_EVRInitError_VRInitError_Init_VRHomeStartupFailed:
          EVRInitError =
    136;
pub const EVRInitError_EVRInitError_VRInitError_Driver_Failed: EVRInitError =
    200;
pub const EVRInitError_EVRInitError_VRInitError_Driver_Unknown: EVRInitError =
    201;
pub const EVRInitError_EVRInitError_VRInitError_Driver_HmdUnknown:
          EVRInitError =
    202;
pub const EVRInitError_EVRInitError_VRInitError_Driver_NotLoaded: EVRInitError
          =
    203;
pub const EVRInitError_EVRInitError_VRInitError_Driver_RuntimeOutOfDate:
          EVRInitError =
    204;
pub const EVRInitError_EVRInitError_VRInitError_Driver_HmdInUse: EVRInitError
          =
    205;
pub const EVRInitError_EVRInitError_VRInitError_Driver_NotCalibrated:
          EVRInitError =
    206;
pub const EVRInitError_EVRInitError_VRInitError_Driver_CalibrationInvalid:
          EVRInitError =
    207;
pub const EVRInitError_EVRInitError_VRInitError_Driver_HmdDisplayNotFound:
          EVRInitError =
    208;
pub const EVRInitError_EVRInitError_VRInitError_Driver_TrackedDeviceInterfaceUnknown:
          EVRInitError =
    209;
pub const EVRInitError_EVRInitError_VRInitError_Driver_HmdDriverIdOutOfBounds:
          EVRInitError =
    211;
pub const EVRInitError_EVRInitError_VRInitError_Driver_HmdDisplayMirrored:
          EVRInitError =
    212;
pub const EVRInitError_EVRInitError_VRInitError_IPC_ServerInitFailed:
          EVRInitError =
    300;
pub const EVRInitError_EVRInitError_VRInitError_IPC_ConnectFailed:
          EVRInitError =
    301;
pub const EVRInitError_EVRInitError_VRInitError_IPC_SharedStateInitFailed:
          EVRInitError =
    302;
pub const EVRInitError_EVRInitError_VRInitError_IPC_CompositorInitFailed:
          EVRInitError =
    303;
pub const EVRInitError_EVRInitError_VRInitError_IPC_MutexInitFailed:
          EVRInitError =
    304;
pub const EVRInitError_EVRInitError_VRInitError_IPC_Failed: EVRInitError =
    305;
pub const EVRInitError_EVRInitError_VRInitError_IPC_CompositorConnectFailed:
          EVRInitError =
    306;
pub const EVRInitError_EVRInitError_VRInitError_IPC_CompositorInvalidConnectResponse:
          EVRInitError =
    307;
pub const EVRInitError_EVRInitError_VRInitError_IPC_ConnectFailedAfterMultipleAttempts:
          EVRInitError =
    308;
pub const EVRInitError_EVRInitError_VRInitError_Compositor_Failed:
          EVRInitError =
    400;
pub const EVRInitError_EVRInitError_VRInitError_Compositor_D3D11HardwareRequired:
          EVRInitError =
    401;
pub const EVRInitError_EVRInitError_VRInitError_Compositor_FirmwareRequiresUpdate:
          EVRInitError =
    402;
pub const EVRInitError_EVRInitError_VRInitError_Compositor_OverlayInitFailed:
          EVRInitError =
    403;
pub const EVRInitError_EVRInitError_VRInitError_Compositor_ScreenshotsInitFailed:
          EVRInitError =
    404;
pub const EVRInitError_EVRInitError_VRInitError_Compositor_UnableToCreateDevice:
          EVRInitError =
    405;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_UnableToConnectToOculusRuntime:
          EVRInitError =
    1000;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_CantOpenDevice:
          EVRInitError =
    1101;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_UnableToRequestConfigStart:
          EVRInitError =
    1102;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_NoStoredConfig:
          EVRInitError =
    1103;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_ConfigTooBig:
          EVRInitError =
    1104;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_ConfigTooSmall:
          EVRInitError =
    1105;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_UnableToInitZLib:
          EVRInitError =
    1106;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_CantReadFirmwareVersion:
          EVRInitError =
    1107;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_UnableToSendUserDataStart:
          EVRInitError =
    1108;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_UnableToGetUserDataStart:
          EVRInitError =
    1109;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_UnableToGetUserDataNext:
          EVRInitError =
    1110;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_UserDataAddressRange:
          EVRInitError =
    1111;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_UserDataError:
          EVRInitError =
    1112;
pub const EVRInitError_EVRInitError_VRInitError_VendorSpecific_HmdFound_ConfigFailedSanityCheck:
          EVRInitError =
    1113;
pub const EVRInitError_EVRInitError_VRInitError_Steam_SteamInstallationNotFound:
          EVRInitError =
    2000;
pub type EVRInitError = ::std::os::raw::c_uint;
pub const EVRScreenshotType_EVRScreenshotType_VRScreenshotType_None:
          EVRScreenshotType =
    0;
pub const EVRScreenshotType_EVRScreenshotType_VRScreenshotType_Mono:
          EVRScreenshotType =
    1;
pub const EVRScreenshotType_EVRScreenshotType_VRScreenshotType_Stereo:
          EVRScreenshotType =
    2;
pub const EVRScreenshotType_EVRScreenshotType_VRScreenshotType_Cubemap:
          EVRScreenshotType =
    3;
pub const EVRScreenshotType_EVRScreenshotType_VRScreenshotType_MonoPanorama:
          EVRScreenshotType =
    4;
pub const EVRScreenshotType_EVRScreenshotType_VRScreenshotType_StereoPanorama:
          EVRScreenshotType =
    5;
pub type EVRScreenshotType = ::std::os::raw::c_uint;
pub const EVRScreenshotPropertyFilenames_EVRScreenshotPropertyFilenames_VRScreenshotPropertyFilenames_Preview:
          EVRScreenshotPropertyFilenames =
    0;
pub const EVRScreenshotPropertyFilenames_EVRScreenshotPropertyFilenames_VRScreenshotPropertyFilenames_VR:
          EVRScreenshotPropertyFilenames =
    1;
pub type EVRScreenshotPropertyFilenames = ::std::os::raw::c_uint;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_None:
          EVRTrackedCameraError =
    0;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_OperationFailed:
          EVRTrackedCameraError =
    100;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_InvalidHandle:
          EVRTrackedCameraError =
    101;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_InvalidFrameHeaderVersion:
          EVRTrackedCameraError =
    102;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_OutOfHandles:
          EVRTrackedCameraError =
    103;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_IPCFailure:
          EVRTrackedCameraError =
    104;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_NotSupportedForThisDevice:
          EVRTrackedCameraError =
    105;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_SharedMemoryFailure:
          EVRTrackedCameraError =
    106;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_FrameBufferingFailure:
          EVRTrackedCameraError =
    107;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_StreamSetupFailure:
          EVRTrackedCameraError =
    108;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_InvalidGLTextureId:
          EVRTrackedCameraError =
    109;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_InvalidSharedTextureHandle:
          EVRTrackedCameraError =
    110;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_FailedToGetGLTextureId:
          EVRTrackedCameraError =
    111;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_SharedTextureFailure:
          EVRTrackedCameraError =
    112;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_NoFrameAvailable:
          EVRTrackedCameraError =
    113;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_InvalidArgument:
          EVRTrackedCameraError =
    114;
pub const EVRTrackedCameraError_EVRTrackedCameraError_VRTrackedCameraError_InvalidFrameBufferSize:
          EVRTrackedCameraError =
    115;
pub type EVRTrackedCameraError = ::std::os::raw::c_uint;
pub const EVRTrackedCameraFrameType_EVRTrackedCameraFrameType_VRTrackedCameraFrameType_Distorted:
          EVRTrackedCameraFrameType =
    0;
pub const EVRTrackedCameraFrameType_EVRTrackedCameraFrameType_VRTrackedCameraFrameType_Undistorted:
          EVRTrackedCameraFrameType =
    1;
pub const EVRTrackedCameraFrameType_EVRTrackedCameraFrameType_VRTrackedCameraFrameType_MaximumUndistorted:
          EVRTrackedCameraFrameType =
    2;
pub const EVRTrackedCameraFrameType_EVRTrackedCameraFrameType_MAX_CAMERA_FRAME_TYPES:
          EVRTrackedCameraFrameType =
    3;
pub type EVRTrackedCameraFrameType = ::std::os::raw::c_uint;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_None:
          EVRApplicationError =
    0;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_AppKeyAlreadyExists:
          EVRApplicationError =
    100;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_NoManifest:
          EVRApplicationError =
    101;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_NoApplication:
          EVRApplicationError =
    102;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_InvalidIndex:
          EVRApplicationError =
    103;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_UnknownApplication:
          EVRApplicationError =
    104;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_IPCFailed:
          EVRApplicationError =
    105;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_ApplicationAlreadyRunning:
          EVRApplicationError =
    106;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_InvalidManifest:
          EVRApplicationError =
    107;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_InvalidApplication:
          EVRApplicationError =
    108;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_LaunchFailed:
          EVRApplicationError =
    109;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_ApplicationAlreadyStarting:
          EVRApplicationError =
    110;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_LaunchInProgress:
          EVRApplicationError =
    111;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_OldApplicationQuitting:
          EVRApplicationError =
    112;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_TransitionAborted:
          EVRApplicationError =
    113;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_IsTemplate:
          EVRApplicationError =
    114;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_BufferTooSmall:
          EVRApplicationError =
    200;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_PropertyNotSet:
          EVRApplicationError =
    201;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_UnknownProperty:
          EVRApplicationError =
    202;
pub const EVRApplicationError_EVRApplicationError_VRApplicationError_InvalidParameter:
          EVRApplicationError =
    203;
pub type EVRApplicationError = ::std::os::raw::c_uint;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_Name_String:
          EVRApplicationProperty =
    0;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_LaunchType_String:
          EVRApplicationProperty =
    11;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_WorkingDirectory_String:
          EVRApplicationProperty =
    12;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_BinaryPath_String:
          EVRApplicationProperty =
    13;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_Arguments_String:
          EVRApplicationProperty =
    14;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_URL_String:
          EVRApplicationProperty =
    15;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_Description_String:
          EVRApplicationProperty =
    50;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_NewsURL_String:
          EVRApplicationProperty =
    51;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_ImagePath_String:
          EVRApplicationProperty =
    52;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_Source_String:
          EVRApplicationProperty =
    53;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_IsDashboardOverlay_Bool:
          EVRApplicationProperty =
    60;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_IsTemplate_Bool:
          EVRApplicationProperty =
    61;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_IsInstanced_Bool:
          EVRApplicationProperty =
    62;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_IsInternal_Bool:
          EVRApplicationProperty =
    63;
pub const EVRApplicationProperty_EVRApplicationProperty_VRApplicationProperty_LastLaunchTime_Uint64:
          EVRApplicationProperty =
    70;
pub type EVRApplicationProperty = ::std::os::raw::c_uint;
pub const EVRApplicationTransitionState_EVRApplicationTransitionState_VRApplicationTransition_None:
          EVRApplicationTransitionState =
    0;
pub const EVRApplicationTransitionState_EVRApplicationTransitionState_VRApplicationTransition_OldAppQuitSent:
          EVRApplicationTransitionState =
    10;
pub const EVRApplicationTransitionState_EVRApplicationTransitionState_VRApplicationTransition_WaitingForExternalLaunch:
          EVRApplicationTransitionState =
    11;
pub const EVRApplicationTransitionState_EVRApplicationTransitionState_VRApplicationTransition_NewAppLaunched:
          EVRApplicationTransitionState =
    20;
pub type EVRApplicationTransitionState = ::std::os::raw::c_uint;
pub const ChaperoneCalibrationState_ChaperoneCalibrationState_OK:
          ChaperoneCalibrationState =
    1;
pub const ChaperoneCalibrationState_ChaperoneCalibrationState_Warning:
          ChaperoneCalibrationState =
    100;
pub const ChaperoneCalibrationState_ChaperoneCalibrationState_Warning_BaseStationMayHaveMoved:
          ChaperoneCalibrationState =
    101;
pub const ChaperoneCalibrationState_ChaperoneCalibrationState_Warning_BaseStationRemoved:
          ChaperoneCalibrationState =
    102;
pub const ChaperoneCalibrationState_ChaperoneCalibrationState_Warning_SeatedBoundsInvalid:
          ChaperoneCalibrationState =
    103;
pub const ChaperoneCalibrationState_ChaperoneCalibrationState_Error:
          ChaperoneCalibrationState =
    200;
pub const ChaperoneCalibrationState_ChaperoneCalibrationState_Error_BaseStationUninitialized:
          ChaperoneCalibrationState =
    201;
pub const ChaperoneCalibrationState_ChaperoneCalibrationState_Error_BaseStationConflict:
          ChaperoneCalibrationState =
    202;
pub const ChaperoneCalibrationState_ChaperoneCalibrationState_Error_PlayAreaInvalid:
          ChaperoneCalibrationState =
    203;
pub const ChaperoneCalibrationState_ChaperoneCalibrationState_Error_CollisionBoundsInvalid:
          ChaperoneCalibrationState =
    204;
pub type ChaperoneCalibrationState = ::std::os::raw::c_uint;
pub const EChaperoneConfigFile_EChaperoneConfigFile_Live: EChaperoneConfigFile
          =
    1;
pub const EChaperoneConfigFile_EChaperoneConfigFile_Temp: EChaperoneConfigFile
          =
    2;
pub type EChaperoneConfigFile = ::std::os::raw::c_uint;
pub const EChaperoneImportFlags_EChaperoneImportFlags_EChaperoneImport_BoundsOnly:
          EChaperoneImportFlags =
    1;
pub type EChaperoneImportFlags = ::std::os::raw::c_uint;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_None:
          EVRCompositorError =
    0;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_RequestFailed:
          EVRCompositorError =
    1;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_IncompatibleVersion:
          EVRCompositorError =
    100;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_DoNotHaveFocus:
          EVRCompositorError =
    101;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_InvalidTexture:
          EVRCompositorError =
    102;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_IsNotSceneApplication:
          EVRCompositorError =
    103;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_TextureIsOnWrongDevice:
          EVRCompositorError =
    104;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_TextureUsesUnsupportedFormat:
          EVRCompositorError =
    105;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_SharedTexturesNotSupported:
          EVRCompositorError =
    106;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_IndexOutOfRange:
          EVRCompositorError =
    107;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_AlreadySubmitted:
          EVRCompositorError =
    108;
pub const EVRCompositorError_EVRCompositorError_VRCompositorError_InvalidBounds:
          EVRCompositorError =
    109;
pub type EVRCompositorError = ::std::os::raw::c_uint;
pub const VROverlayInputMethod_VROverlayInputMethod_None: VROverlayInputMethod
          =
    0;
pub const VROverlayInputMethod_VROverlayInputMethod_Mouse:
          VROverlayInputMethod =
    1;
pub type VROverlayInputMethod = ::std::os::raw::c_uint;
pub const VROverlayTransformType_VROverlayTransformType_VROverlayTransform_Absolute:
          VROverlayTransformType =
    0;
pub const VROverlayTransformType_VROverlayTransformType_VROverlayTransform_TrackedDeviceRelative:
          VROverlayTransformType =
    1;
pub const VROverlayTransformType_VROverlayTransformType_VROverlayTransform_SystemOverlay:
          VROverlayTransformType =
    2;
pub const VROverlayTransformType_VROverlayTransformType_VROverlayTransform_TrackedComponent:
          VROverlayTransformType =
    3;
pub type VROverlayTransformType = ::std::os::raw::c_uint;
pub const VROverlayFlags_VROverlayFlags_None: VROverlayFlags = 0;
pub const VROverlayFlags_VROverlayFlags_Curved: VROverlayFlags = 1;
pub const VROverlayFlags_VROverlayFlags_RGSS4X: VROverlayFlags = 2;
pub const VROverlayFlags_VROverlayFlags_NoDashboardTab: VROverlayFlags = 3;
pub const VROverlayFlags_VROverlayFlags_AcceptsGamepadEvents: VROverlayFlags =
    4;
pub const VROverlayFlags_VROverlayFlags_ShowGamepadFocus: VROverlayFlags = 5;
pub const VROverlayFlags_VROverlayFlags_SendVRScrollEvents: VROverlayFlags =
    6;
pub const VROverlayFlags_VROverlayFlags_SendVRTouchpadEvents: VROverlayFlags =
    7;
pub const VROverlayFlags_VROverlayFlags_ShowTouchPadScrollWheel:
          VROverlayFlags =
    8;
pub const VROverlayFlags_VROverlayFlags_TransferOwnershipToInternalProcess:
          VROverlayFlags =
    9;
pub const VROverlayFlags_VROverlayFlags_SideBySide_Parallel: VROverlayFlags =
    10;
pub const VROverlayFlags_VROverlayFlags_SideBySide_Crossed: VROverlayFlags =
    11;
pub const VROverlayFlags_VROverlayFlags_Panorama: VROverlayFlags = 12;
pub const VROverlayFlags_VROverlayFlags_StereoPanorama: VROverlayFlags = 13;
pub const VROverlayFlags_VROverlayFlags_SortWithNonSceneOverlays:
          VROverlayFlags =
    14;
pub const VROverlayFlags_VROverlayFlags_VisibleInDashboard: VROverlayFlags =
    15;
pub type VROverlayFlags = ::std::os::raw::c_uint;
pub const VRMessageOverlayResponse_VRMessageOverlayResponse_ButtonPress_0:
          VRMessageOverlayResponse =
    0;
pub const VRMessageOverlayResponse_VRMessageOverlayResponse_ButtonPress_1:
          VRMessageOverlayResponse =
    1;
pub const VRMessageOverlayResponse_VRMessageOverlayResponse_ButtonPress_2:
          VRMessageOverlayResponse =
    2;
pub const VRMessageOverlayResponse_VRMessageOverlayResponse_ButtonPress_3:
          VRMessageOverlayResponse =
    3;
pub const VRMessageOverlayResponse_VRMessageOverlayResponse_CouldntFindSystemOverlay:
          VRMessageOverlayResponse =
    4;
pub const VRMessageOverlayResponse_VRMessageOverlayResponse_CouldntFindOrCreateClientOverlay:
          VRMessageOverlayResponse =
    5;
pub const VRMessageOverlayResponse_VRMessageOverlayResponse_ApplicationQuit:
          VRMessageOverlayResponse =
    6;
pub type VRMessageOverlayResponse = ::std::os::raw::c_uint;
pub const EGamepadTextInputMode_EGamepadTextInputMode_k_EGamepadTextInputModeNormal:
          EGamepadTextInputMode =
    0;
pub const EGamepadTextInputMode_EGamepadTextInputMode_k_EGamepadTextInputModePassword:
          EGamepadTextInputMode =
    1;
pub const EGamepadTextInputMode_EGamepadTextInputMode_k_EGamepadTextInputModeSubmit:
          EGamepadTextInputMode =
    2;
pub type EGamepadTextInputMode = ::std::os::raw::c_uint;
pub const EGamepadTextInputLineMode_EGamepadTextInputLineMode_k_EGamepadTextInputLineModeSingleLine:
          EGamepadTextInputLineMode =
    0;
pub const EGamepadTextInputLineMode_EGamepadTextInputLineMode_k_EGamepadTextInputLineModeMultipleLines:
          EGamepadTextInputLineMode =
    1;
pub type EGamepadTextInputLineMode = ::std::os::raw::c_uint;
pub const EOverlayDirection_EOverlayDirection_OverlayDirection_Up:
          EOverlayDirection =
    0;
pub const EOverlayDirection_EOverlayDirection_OverlayDirection_Down:
          EOverlayDirection =
    1;
pub const EOverlayDirection_EOverlayDirection_OverlayDirection_Left:
          EOverlayDirection =
    2;
pub const EOverlayDirection_EOverlayDirection_OverlayDirection_Right:
          EOverlayDirection =
    3;
pub const EOverlayDirection_EOverlayDirection_OverlayDirection_Count:
          EOverlayDirection =
    4;
pub type EOverlayDirection = ::std::os::raw::c_uint;
pub const EVROverlayIntersectionMaskPrimitiveType_EVROverlayIntersectionMaskPrimitiveType_OverlayIntersectionPrimitiveType_Rectangle:
          EVROverlayIntersectionMaskPrimitiveType =
    0;
pub const EVROverlayIntersectionMaskPrimitiveType_EVROverlayIntersectionMaskPrimitiveType_OverlayIntersectionPrimitiveType_Circle:
          EVROverlayIntersectionMaskPrimitiveType =
    1;
pub type EVROverlayIntersectionMaskPrimitiveType = ::std::os::raw::c_uint;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_None:
          EVRRenderModelError =
    0;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_Loading:
          EVRRenderModelError =
    100;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_NotSupported:
          EVRRenderModelError =
    200;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_InvalidArg:
          EVRRenderModelError =
    300;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_InvalidModel:
          EVRRenderModelError =
    301;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_NoShapes:
          EVRRenderModelError =
    302;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_MultipleShapes:
          EVRRenderModelError =
    303;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_TooManyVertices:
          EVRRenderModelError =
    304;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_MultipleTextures:
          EVRRenderModelError =
    305;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_BufferTooSmall:
          EVRRenderModelError =
    306;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_NotEnoughNormals:
          EVRRenderModelError =
    307;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_NotEnoughTexCoords:
          EVRRenderModelError =
    308;
pub const EVRRenderModelError_EVRRenderModelError_VRRenderModelError_InvalidTexture:
          EVRRenderModelError =
    400;
pub type EVRRenderModelError = ::std::os::raw::c_uint;
pub const EVRComponentProperty_EVRComponentProperty_VRComponentProperty_IsStatic:
          EVRComponentProperty =
    1;
pub const EVRComponentProperty_EVRComponentProperty_VRComponentProperty_IsVisible:
          EVRComponentProperty =
    2;
pub const EVRComponentProperty_EVRComponentProperty_VRComponentProperty_IsTouched:
          EVRComponentProperty =
    4;
pub const EVRComponentProperty_EVRComponentProperty_VRComponentProperty_IsPressed:
          EVRComponentProperty =
    8;
pub const EVRComponentProperty_EVRComponentProperty_VRComponentProperty_IsScrolled:
          EVRComponentProperty =
    16;
pub type EVRComponentProperty = ::std::os::raw::c_uint;
pub const EVRNotificationType_EVRNotificationType_Transient:
          EVRNotificationType =
    0;
pub const EVRNotificationType_EVRNotificationType_Persistent:
          EVRNotificationType =
    1;
pub const EVRNotificationType_EVRNotificationType_Transient_SystemWithUserValue:
          EVRNotificationType =
    2;
pub type EVRNotificationType = ::std::os::raw::c_uint;
pub const EVRNotificationStyle_EVRNotificationStyle_None: EVRNotificationStyle
          =
    0;
pub const EVRNotificationStyle_EVRNotificationStyle_Application:
          EVRNotificationStyle =
    100;
pub const EVRNotificationStyle_EVRNotificationStyle_Contact_Disabled:
          EVRNotificationStyle =
    200;
pub const EVRNotificationStyle_EVRNotificationStyle_Contact_Enabled:
          EVRNotificationStyle =
    201;
pub const EVRNotificationStyle_EVRNotificationStyle_Contact_Active:
          EVRNotificationStyle =
    202;
pub type EVRNotificationStyle = ::std::os::raw::c_uint;
pub const EVRSettingsError_EVRSettingsError_VRSettingsError_None:
          EVRSettingsError =
    0;
pub const EVRSettingsError_EVRSettingsError_VRSettingsError_IPCFailed:
          EVRSettingsError =
    1;
pub const EVRSettingsError_EVRSettingsError_VRSettingsError_WriteFailed:
          EVRSettingsError =
    2;
pub const EVRSettingsError_EVRSettingsError_VRSettingsError_ReadFailed:
          EVRSettingsError =
    3;
pub const EVRSettingsError_EVRSettingsError_VRSettingsError_JsonParseFailed:
          EVRSettingsError =
    4;
pub const EVRSettingsError_EVRSettingsError_VRSettingsError_UnsetSettingHasNoDefault:
          EVRSettingsError =
    5;
pub type EVRSettingsError = ::std::os::raw::c_uint;
pub const EVRScreenshotError_EVRScreenshotError_VRScreenshotError_None:
          EVRScreenshotError =
    0;
pub const EVRScreenshotError_EVRScreenshotError_VRScreenshotError_RequestFailed:
          EVRScreenshotError =
    1;
pub const EVRScreenshotError_EVRScreenshotError_VRScreenshotError_IncompatibleVersion:
          EVRScreenshotError =
    100;
pub const EVRScreenshotError_EVRScreenshotError_VRScreenshotError_NotFound:
          EVRScreenshotError =
    101;
pub const EVRScreenshotError_EVRScreenshotError_VRScreenshotError_BufferTooSmall:
          EVRScreenshotError =
    102;
pub const EVRScreenshotError_EVRScreenshotError_VRScreenshotError_ScreenshotAlreadyInProgress:
          EVRScreenshotError =
    108;
pub type EVRScreenshotError = ::std::os::raw::c_uint;
pub type TrackedDeviceIndex_t = u32;
pub type VRNotificationId = u32;
pub type VROverlayHandle_t = u64;
pub type glSharedTextureHandle_t = *mut ::std::os::raw::c_void;
pub type glInt_t = i32;
pub type glUInt_t = u32;
pub type SharedTextureHandle_t = u64;
pub type DriverId_t = u32;
pub type TrackedCameraHandle_t = u64;
pub type ScreenshotHandle_t = u32;
pub type VRComponentProperties = u32;
pub type TextureID_t = i32;
pub use self::EVRInitError as HmdError;
pub use self::EVREye as Hmd_Eye;
pub use self::EColorSpace as ColorSpace;
pub use self::ETrackingResult as HmdTrackingResult;
pub use self::ETrackedDeviceClass as TrackedDeviceClass;
pub use self::ETrackingUniverseOrigin as TrackingUniverseOrigin;
pub use self::ETrackedDeviceProperty as TrackedDeviceProperty;
pub use self::ETrackedPropertyError as TrackedPropertyError;
pub use self::EVRSubmitFlags as VRSubmitFlags_t;
pub use self::EVRState as VRState_t;
pub use self::ECollisionBoundsStyle as CollisionBoundsStyle_t;
pub use self::EVROverlayError as VROverlayError;
pub use self::EVRFirmwareError as VRFirmwareError;
pub use self::EVRCompositorError as VRCompositorError;
pub use self::EVRScreenshotError as VRScreenshotsError;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HmdMatrix34_t {
    pub m: [[f32; 4usize]; 3usize],
}
#[test]
fn bindgen_test_layout_HmdMatrix34_t() {
    assert_eq!(::std::mem::size_of::<HmdMatrix34_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( HmdMatrix34_t ) ));
    assert_eq! (::std::mem::align_of::<HmdMatrix34_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( HmdMatrix34_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdMatrix34_t ) ) . m as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdMatrix34_t ) , "::"
                , stringify ! ( m ) ));
}
impl Clone for HmdMatrix34_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HmdMatrix44_t {
    pub m: [[f32; 4usize]; 4usize],
}
#[test]
fn bindgen_test_layout_HmdMatrix44_t() {
    assert_eq!(::std::mem::size_of::<HmdMatrix44_t>() , 64usize , concat ! (
               "Size of: " , stringify ! ( HmdMatrix44_t ) ));
    assert_eq! (::std::mem::align_of::<HmdMatrix44_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( HmdMatrix44_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdMatrix44_t ) ) . m as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdMatrix44_t ) , "::"
                , stringify ! ( m ) ));
}
impl Clone for HmdMatrix44_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HmdVector3_t {
    pub v: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_HmdVector3_t() {
    assert_eq!(::std::mem::size_of::<HmdVector3_t>() , 12usize , concat ! (
               "Size of: " , stringify ! ( HmdVector3_t ) ));
    assert_eq! (::std::mem::align_of::<HmdVector3_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( HmdVector3_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdVector3_t ) ) . v as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdVector3_t ) , "::" ,
                stringify ! ( v ) ));
}
impl Clone for HmdVector3_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HmdVector4_t {
    pub v: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_HmdVector4_t() {
    assert_eq!(::std::mem::size_of::<HmdVector4_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( HmdVector4_t ) ));
    assert_eq! (::std::mem::align_of::<HmdVector4_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( HmdVector4_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdVector4_t ) ) . v as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdVector4_t ) , "::" ,
                stringify ! ( v ) ));
}
impl Clone for HmdVector4_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HmdVector3d_t {
    pub v: [f64; 3usize],
}
#[test]
fn bindgen_test_layout_HmdVector3d_t() {
    assert_eq!(::std::mem::size_of::<HmdVector3d_t>() , 24usize , concat ! (
               "Size of: " , stringify ! ( HmdVector3d_t ) ));
    assert_eq! (::std::mem::align_of::<HmdVector3d_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( HmdVector3d_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdVector3d_t ) ) . v as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdVector3d_t ) , "::"
                , stringify ! ( v ) ));
}
impl Clone for HmdVector3d_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HmdVector2_t {
    pub v: [f32; 2usize],
}
#[test]
fn bindgen_test_layout_HmdVector2_t() {
    assert_eq!(::std::mem::size_of::<HmdVector2_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( HmdVector2_t ) ));
    assert_eq! (::std::mem::align_of::<HmdVector2_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( HmdVector2_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdVector2_t ) ) . v as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdVector2_t ) , "::" ,
                stringify ! ( v ) ));
}
impl Clone for HmdVector2_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HmdQuaternion_t {
    pub w: f64,
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_HmdQuaternion_t() {
    assert_eq!(::std::mem::size_of::<HmdQuaternion_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( HmdQuaternion_t ) ));
    assert_eq! (::std::mem::align_of::<HmdQuaternion_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( HmdQuaternion_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdQuaternion_t ) ) . w as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdQuaternion_t ) ,
                "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdQuaternion_t ) ) . x as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdQuaternion_t ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdQuaternion_t ) ) . y as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdQuaternion_t ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdQuaternion_t ) ) . z as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdQuaternion_t ) ,
                "::" , stringify ! ( z ) ));
}
impl Clone for HmdQuaternion_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HmdColor_t {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[test]
fn bindgen_test_layout_HmdColor_t() {
    assert_eq!(::std::mem::size_of::<HmdColor_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( HmdColor_t ) ));
    assert_eq! (::std::mem::align_of::<HmdColor_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( HmdColor_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdColor_t ) ) . r as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdColor_t ) , "::" ,
                stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdColor_t ) ) . g as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdColor_t ) , "::" ,
                stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdColor_t ) ) . b as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdColor_t ) , "::" ,
                stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdColor_t ) ) . a as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdColor_t ) , "::" ,
                stringify ! ( a ) ));
}
impl Clone for HmdColor_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HmdQuad_t {
    pub vCorners: [HmdVector3_t; 4usize],
}
#[test]
fn bindgen_test_layout_HmdQuad_t() {
    assert_eq!(::std::mem::size_of::<HmdQuad_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( HmdQuad_t ) ));
    assert_eq! (::std::mem::align_of::<HmdQuad_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( HmdQuad_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdQuad_t ) ) . vCorners as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdQuad_t ) , "::" ,
                stringify ! ( vCorners ) ));
}
impl Clone for HmdQuad_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HmdRect2_t {
    pub vTopLeft: HmdVector2_t,
    pub vBottomRight: HmdVector2_t,
}
#[test]
fn bindgen_test_layout_HmdRect2_t() {
    assert_eq!(::std::mem::size_of::<HmdRect2_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( HmdRect2_t ) ));
    assert_eq! (::std::mem::align_of::<HmdRect2_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( HmdRect2_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdRect2_t ) ) . vTopLeft as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdRect2_t ) , "::" ,
                stringify ! ( vTopLeft ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HmdRect2_t ) ) . vBottomRight as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( HmdRect2_t ) , "::" ,
                stringify ! ( vBottomRight ) ));
}
impl Clone for HmdRect2_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DistortionCoordinates_t {
    pub rfRed: [f32; 2usize],
    pub rfGreen: [f32; 2usize],
    pub rfBlue: [f32; 2usize],
}
#[test]
fn bindgen_test_layout_DistortionCoordinates_t() {
    assert_eq!(::std::mem::size_of::<DistortionCoordinates_t>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( DistortionCoordinates_t ) ));
    assert_eq! (::std::mem::align_of::<DistortionCoordinates_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( DistortionCoordinates_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DistortionCoordinates_t ) ) . rfRed as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DistortionCoordinates_t
                ) , "::" , stringify ! ( rfRed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DistortionCoordinates_t ) ) . rfGreen as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DistortionCoordinates_t
                ) , "::" , stringify ! ( rfGreen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DistortionCoordinates_t ) ) . rfBlue as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DistortionCoordinates_t
                ) , "::" , stringify ! ( rfBlue ) ));
}
impl Clone for DistortionCoordinates_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Texture_t {
    pub handle: *mut ::std::os::raw::c_void,
    pub eType: ETextureType,
    pub eColorSpace: EColorSpace,
}
#[test]
fn bindgen_test_layout_Texture_t() {
    assert_eq!(::std::mem::size_of::<Texture_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( Texture_t ) ));
    assert_eq! (::std::mem::align_of::<Texture_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Texture_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Texture_t ) ) . handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Texture_t ) , "::" ,
                stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Texture_t ) ) . eType as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Texture_t ) , "::" ,
                stringify ! ( eType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Texture_t ) ) . eColorSpace as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( Texture_t ) , "::" ,
                stringify ! ( eColorSpace ) ));
}
impl Clone for Texture_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TrackedDevicePose_t {
    pub mDeviceToAbsoluteTracking: HmdMatrix34_t,
    pub vVelocity: HmdVector3_t,
    pub vAngularVelocity: HmdVector3_t,
    pub eTrackingResult: ETrackingResult,
    pub bPoseIsValid: bool,
    pub bDeviceIsConnected: bool,
}
#[test]
fn bindgen_test_layout_TrackedDevicePose_t() {
    assert_eq!(::std::mem::size_of::<TrackedDevicePose_t>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( TrackedDevicePose_t ) ));
    assert_eq! (::std::mem::align_of::<TrackedDevicePose_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TrackedDevicePose_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TrackedDevicePose_t ) ) .
                mDeviceToAbsoluteTracking as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( TrackedDevicePose_t ) ,
                "::" , stringify ! ( mDeviceToAbsoluteTracking ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TrackedDevicePose_t ) ) . vVelocity as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( TrackedDevicePose_t ) ,
                "::" , stringify ! ( vVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TrackedDevicePose_t ) ) .
                vAngularVelocity as * const _ as usize } , 60usize , concat !
                (
                "Alignment of field: " , stringify ! ( TrackedDevicePose_t ) ,
                "::" , stringify ! ( vAngularVelocity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TrackedDevicePose_t ) ) . eTrackingResult
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( TrackedDevicePose_t ) ,
                "::" , stringify ! ( eTrackingResult ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TrackedDevicePose_t ) ) . bPoseIsValid as
                * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( TrackedDevicePose_t ) ,
                "::" , stringify ! ( bPoseIsValid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TrackedDevicePose_t ) ) .
                bDeviceIsConnected as * const _ as usize } , 77usize , concat
                ! (
                "Alignment of field: " , stringify ! ( TrackedDevicePose_t ) ,
                "::" , stringify ! ( bDeviceIsConnected ) ));
}
impl Clone for TrackedDevicePose_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VRTextureBounds_t {
    pub uMin: f32,
    pub vMin: f32,
    pub uMax: f32,
    pub vMax: f32,
}
#[test]
fn bindgen_test_layout_VRTextureBounds_t() {
    assert_eq!(::std::mem::size_of::<VRTextureBounds_t>() , 16usize , concat !
               ( "Size of: " , stringify ! ( VRTextureBounds_t ) ));
    assert_eq! (::std::mem::align_of::<VRTextureBounds_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VRTextureBounds_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRTextureBounds_t ) ) . uMin as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VRTextureBounds_t ) ,
                "::" , stringify ! ( uMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRTextureBounds_t ) ) . vMin as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VRTextureBounds_t ) ,
                "::" , stringify ! ( vMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRTextureBounds_t ) ) . uMax as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VRTextureBounds_t ) ,
                "::" , stringify ! ( uMax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRTextureBounds_t ) ) . vMax as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VRTextureBounds_t ) ,
                "::" , stringify ! ( vMax ) ));
}
impl Clone for VRTextureBounds_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VRVulkanTextureData_t {
    pub m_nImage: u64,
    pub m_pDevice: *mut VkDevice_T,
    pub m_pPhysicalDevice: *mut VkPhysicalDevice_T,
    pub m_pInstance: *mut VkInstance_T,
    pub m_pQueue: *mut VkQueue_T,
    pub m_nQueueFamilyIndex: u32,
    pub m_nWidth: u32,
    pub m_nHeight: u32,
    pub m_nFormat: u32,
    pub m_nSampleCount: u32,
}
#[test]
fn bindgen_test_layout_VRVulkanTextureData_t() {
    assert_eq!(::std::mem::size_of::<VRVulkanTextureData_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( VRVulkanTextureData_t )
               ));
    assert_eq! (::std::mem::align_of::<VRVulkanTextureData_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VRVulkanTextureData_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRVulkanTextureData_t ) ) . m_nImage as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VRVulkanTextureData_t )
                , "::" , stringify ! ( m_nImage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRVulkanTextureData_t ) ) . m_pDevice as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VRVulkanTextureData_t )
                , "::" , stringify ! ( m_pDevice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRVulkanTextureData_t ) ) .
                m_pPhysicalDevice as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( VRVulkanTextureData_t )
                , "::" , stringify ! ( m_pPhysicalDevice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRVulkanTextureData_t ) ) . m_pInstance
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VRVulkanTextureData_t )
                , "::" , stringify ! ( m_pInstance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRVulkanTextureData_t ) ) . m_pQueue as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VRVulkanTextureData_t )
                , "::" , stringify ! ( m_pQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRVulkanTextureData_t ) ) .
                m_nQueueFamilyIndex as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VRVulkanTextureData_t )
                , "::" , stringify ! ( m_nQueueFamilyIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRVulkanTextureData_t ) ) . m_nWidth as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( VRVulkanTextureData_t )
                , "::" , stringify ! ( m_nWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRVulkanTextureData_t ) ) . m_nHeight as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VRVulkanTextureData_t )
                , "::" , stringify ! ( m_nHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRVulkanTextureData_t ) ) . m_nFormat as
                * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( VRVulkanTextureData_t )
                , "::" , stringify ! ( m_nFormat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRVulkanTextureData_t ) ) .
                m_nSampleCount as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VRVulkanTextureData_t )
                , "::" , stringify ! ( m_nSampleCount ) ));
}
impl Clone for VRVulkanTextureData_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct D3D12TextureData_t {
    pub m_pResource: *mut ID3D12Resource,
    pub m_pCommandQueue: *mut ID3D12CommandQueue,
    pub m_nNodeMask: u32,
}
#[test]
fn bindgen_test_layout_D3D12TextureData_t() {
    assert_eq!(::std::mem::size_of::<D3D12TextureData_t>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( D3D12TextureData_t ) ));
    assert_eq! (::std::mem::align_of::<D3D12TextureData_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( D3D12TextureData_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const D3D12TextureData_t ) ) . m_pResource as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( D3D12TextureData_t ) ,
                "::" , stringify ! ( m_pResource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const D3D12TextureData_t ) ) . m_pCommandQueue
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( D3D12TextureData_t ) ,
                "::" , stringify ! ( m_pCommandQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const D3D12TextureData_t ) ) . m_nNodeMask as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( D3D12TextureData_t ) ,
                "::" , stringify ! ( m_nNodeMask ) ));
}
impl Clone for D3D12TextureData_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Controller_t {
    pub button: u32,
}
#[test]
fn bindgen_test_layout_VREvent_Controller_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Controller_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( VREvent_Controller_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Controller_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VREvent_Controller_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Controller_t ) ) . button as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Controller_t )
                , "::" , stringify ! ( button ) ));
}
impl Clone for VREvent_Controller_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Mouse_t {
    pub x: f32,
    pub y: f32,
    pub button: u32,
}
#[test]
fn bindgen_test_layout_VREvent_Mouse_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Mouse_t>() , 12usize , concat ! (
               "Size of: " , stringify ! ( VREvent_Mouse_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Mouse_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( VREvent_Mouse_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Mouse_t ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Mouse_t ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Mouse_t ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Mouse_t ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Mouse_t ) ) . button as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Mouse_t ) ,
                "::" , stringify ! ( button ) ));
}
impl Clone for VREvent_Mouse_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Scroll_t {
    pub xdelta: f32,
    pub ydelta: f32,
    pub repeatCount: u32,
}
#[test]
fn bindgen_test_layout_VREvent_Scroll_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Scroll_t>() , 12usize , concat !
               ( "Size of: " , stringify ! ( VREvent_Scroll_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Scroll_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( VREvent_Scroll_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Scroll_t ) ) . xdelta as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Scroll_t ) ,
                "::" , stringify ! ( xdelta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Scroll_t ) ) . ydelta as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Scroll_t ) ,
                "::" , stringify ! ( ydelta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Scroll_t ) ) . repeatCount as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Scroll_t ) ,
                "::" , stringify ! ( repeatCount ) ));
}
impl Clone for VREvent_Scroll_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_TouchPadMove_t {
    pub bFingerDown: bool,
    pub flSecondsFingerDown: f32,
    pub fValueXFirst: f32,
    pub fValueYFirst: f32,
    pub fValueXRaw: f32,
    pub fValueYRaw: f32,
}
#[test]
fn bindgen_test_layout_VREvent_TouchPadMove_t() {
    assert_eq!(::std::mem::size_of::<VREvent_TouchPadMove_t>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( VREvent_TouchPadMove_t )
               ));
    assert_eq! (::std::mem::align_of::<VREvent_TouchPadMove_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VREvent_TouchPadMove_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_TouchPadMove_t ) ) . bFingerDown
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_TouchPadMove_t
                ) , "::" , stringify ! ( bFingerDown ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_TouchPadMove_t ) ) .
                flSecondsFingerDown as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VREvent_TouchPadMove_t
                ) , "::" , stringify ! ( flSecondsFingerDown ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_TouchPadMove_t ) ) . fValueXFirst
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_TouchPadMove_t
                ) , "::" , stringify ! ( fValueXFirst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_TouchPadMove_t ) ) . fValueYFirst
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_TouchPadMove_t
                ) , "::" , stringify ! ( fValueYFirst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_TouchPadMove_t ) ) . fValueXRaw
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_TouchPadMove_t
                ) , "::" , stringify ! ( fValueXRaw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_TouchPadMove_t ) ) . fValueYRaw
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_TouchPadMove_t
                ) , "::" , stringify ! ( fValueYRaw ) ));
}
impl Clone for VREvent_TouchPadMove_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Notification_t {
    pub ulUserValue: u64,
    pub notificationId: u32,
}
#[test]
fn bindgen_test_layout_VREvent_Notification_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Notification_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( VREvent_Notification_t )
               ));
    assert_eq! (::std::mem::align_of::<VREvent_Notification_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VREvent_Notification_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Notification_t ) ) . ulUserValue
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Notification_t
                ) , "::" , stringify ! ( ulUserValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Notification_t ) ) .
                notificationId as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Notification_t
                ) , "::" , stringify ! ( notificationId ) ));
}
impl Clone for VREvent_Notification_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Process_t {
    pub pid: u32,
    pub oldPid: u32,
    pub bForced: bool,
}
#[test]
fn bindgen_test_layout_VREvent_Process_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Process_t>() , 12usize , concat !
               ( "Size of: " , stringify ! ( VREvent_Process_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Process_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VREvent_Process_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Process_t ) ) . pid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Process_t ) ,
                "::" , stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Process_t ) ) . oldPid as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Process_t ) ,
                "::" , stringify ! ( oldPid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Process_t ) ) . bForced as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Process_t ) ,
                "::" , stringify ! ( bForced ) ));
}
impl Clone for VREvent_Process_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Overlay_t {
    pub overlayHandle: u64,
}
#[test]
fn bindgen_test_layout_VREvent_Overlay_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Overlay_t>() , 8usize , concat !
               ( "Size of: " , stringify ! ( VREvent_Overlay_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Overlay_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VREvent_Overlay_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Overlay_t ) ) . overlayHandle as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Overlay_t ) ,
                "::" , stringify ! ( overlayHandle ) ));
}
impl Clone for VREvent_Overlay_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Status_t {
    pub statusState: u32,
}
#[test]
fn bindgen_test_layout_VREvent_Status_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Status_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( VREvent_Status_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Status_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( VREvent_Status_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Status_t ) ) . statusState as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Status_t ) ,
                "::" , stringify ! ( statusState ) ));
}
impl Clone for VREvent_Status_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Keyboard_t {
    pub cNewInput: [*mut ::std::os::raw::c_char; 8usize],
    pub uUserValue: u64,
}
#[test]
fn bindgen_test_layout_VREvent_Keyboard_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Keyboard_t>() , 72usize , concat
               ! ( "Size of: " , stringify ! ( VREvent_Keyboard_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Keyboard_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VREvent_Keyboard_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Keyboard_t ) ) . cNewInput as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Keyboard_t ) ,
                "::" , stringify ! ( cNewInput ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Keyboard_t ) ) . uUserValue as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Keyboard_t ) ,
                "::" , stringify ! ( uUserValue ) ));
}
impl Clone for VREvent_Keyboard_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Ipd_t {
    pub ipdMeters: f32,
}
#[test]
fn bindgen_test_layout_VREvent_Ipd_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Ipd_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( VREvent_Ipd_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Ipd_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VREvent_Ipd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Ipd_t ) ) . ipdMeters as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Ipd_t ) , "::"
                , stringify ! ( ipdMeters ) ));
}
impl Clone for VREvent_Ipd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Chaperone_t {
    pub m_nPreviousUniverse: u64,
    pub m_nCurrentUniverse: u64,
}
#[test]
fn bindgen_test_layout_VREvent_Chaperone_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Chaperone_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( VREvent_Chaperone_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Chaperone_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VREvent_Chaperone_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Chaperone_t ) ) .
                m_nPreviousUniverse as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VREvent_Chaperone_t ) ,
                "::" , stringify ! ( m_nPreviousUniverse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Chaperone_t ) ) .
                m_nCurrentUniverse as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( VREvent_Chaperone_t ) ,
                "::" , stringify ! ( m_nCurrentUniverse ) ));
}
impl Clone for VREvent_Chaperone_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Reserved_t {
    pub reserved0: u64,
    pub reserved1: u64,
}
#[test]
fn bindgen_test_layout_VREvent_Reserved_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Reserved_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( VREvent_Reserved_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Reserved_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VREvent_Reserved_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Reserved_t ) ) . reserved0 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Reserved_t ) ,
                "::" , stringify ! ( reserved0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Reserved_t ) ) . reserved1 as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Reserved_t ) ,
                "::" , stringify ! ( reserved1 ) ));
}
impl Clone for VREvent_Reserved_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_PerformanceTest_t {
    pub m_nFidelityLevel: u32,
}
#[test]
fn bindgen_test_layout_VREvent_PerformanceTest_t() {
    assert_eq!(::std::mem::size_of::<VREvent_PerformanceTest_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( VREvent_PerformanceTest_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_PerformanceTest_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VREvent_PerformanceTest_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_PerformanceTest_t ) ) .
                m_nFidelityLevel as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VREvent_PerformanceTest_t ) , "::" , stringify ! (
                m_nFidelityLevel ) ));
}
impl Clone for VREvent_PerformanceTest_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_SeatedZeroPoseReset_t {
    pub bResetBySystemMenu: bool,
}
#[test]
fn bindgen_test_layout_VREvent_SeatedZeroPoseReset_t() {
    assert_eq!(::std::mem::size_of::<VREvent_SeatedZeroPoseReset_t>() , 1usize
               , concat ! (
               "Size of: " , stringify ! ( VREvent_SeatedZeroPoseReset_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_SeatedZeroPoseReset_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( VREvent_SeatedZeroPoseReset_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_SeatedZeroPoseReset_t ) ) .
                bResetBySystemMenu as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VREvent_SeatedZeroPoseReset_t ) , "::" , stringify ! (
                bResetBySystemMenu ) ));
}
impl Clone for VREvent_SeatedZeroPoseReset_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Screenshot_t {
    pub handle: u32,
    pub type_: u32,
}
#[test]
fn bindgen_test_layout_VREvent_Screenshot_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Screenshot_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( VREvent_Screenshot_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Screenshot_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VREvent_Screenshot_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Screenshot_t ) ) . handle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Screenshot_t )
                , "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Screenshot_t ) ) . type_ as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Screenshot_t )
                , "::" , stringify ! ( type_ ) ));
}
impl Clone for VREvent_Screenshot_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_ScreenshotProgress_t {
    pub progress: f32,
}
#[test]
fn bindgen_test_layout_VREvent_ScreenshotProgress_t() {
    assert_eq!(::std::mem::size_of::<VREvent_ScreenshotProgress_t>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( VREvent_ScreenshotProgress_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_ScreenshotProgress_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( VREvent_ScreenshotProgress_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_ScreenshotProgress_t ) ) .
                progress as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VREvent_ScreenshotProgress_t ) , "::" , stringify ! ( progress
                ) ));
}
impl Clone for VREvent_ScreenshotProgress_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_ApplicationLaunch_t {
    pub pid: u32,
    pub unArgsHandle: u32,
}
#[test]
fn bindgen_test_layout_VREvent_ApplicationLaunch_t() {
    assert_eq!(::std::mem::size_of::<VREvent_ApplicationLaunch_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( VREvent_ApplicationLaunch_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_ApplicationLaunch_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( VREvent_ApplicationLaunch_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_ApplicationLaunch_t ) ) . pid as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VREvent_ApplicationLaunch_t ) , "::" , stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_ApplicationLaunch_t ) ) .
                unArgsHandle as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VREvent_ApplicationLaunch_t ) , "::" , stringify ! (
                unArgsHandle ) ));
}
impl Clone for VREvent_ApplicationLaunch_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_EditingCameraSurface_t {
    pub overlayHandle: u64,
    pub nVisualMode: u32,
}
#[test]
fn bindgen_test_layout_VREvent_EditingCameraSurface_t() {
    assert_eq!(::std::mem::size_of::<VREvent_EditingCameraSurface_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( VREvent_EditingCameraSurface_t )
               ));
    assert_eq! (::std::mem::align_of::<VREvent_EditingCameraSurface_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VREvent_EditingCameraSurface_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_EditingCameraSurface_t ) ) .
                overlayHandle as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VREvent_EditingCameraSurface_t ) , "::" , stringify ! (
                overlayHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_EditingCameraSurface_t ) ) .
                nVisualMode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VREvent_EditingCameraSurface_t ) , "::" , stringify ! (
                nVisualMode ) ));
}
impl Clone for VREvent_EditingCameraSurface_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_MessageOverlay_t {
    pub unVRMessageOverlayResponse: u32,
}
#[test]
fn bindgen_test_layout_VREvent_MessageOverlay_t() {
    assert_eq!(::std::mem::size_of::<VREvent_MessageOverlay_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( VREvent_MessageOverlay_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_MessageOverlay_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VREvent_MessageOverlay_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_MessageOverlay_t ) ) .
                unVRMessageOverlayResponse as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VREvent_MessageOverlay_t ) , "::" , stringify ! (
                unVRMessageOverlayResponse ) ));
}
impl Clone for VREvent_MessageOverlay_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Property_t {
    pub container: PropertyContainerHandle_t,
    pub prop: ETrackedDeviceProperty,
}
#[test]
fn bindgen_test_layout_VREvent_Property_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Property_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( VREvent_Property_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Property_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VREvent_Property_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Property_t ) ) . container as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Property_t ) ,
                "::" , stringify ! ( container ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Property_t ) ) . prop as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Property_t ) ,
                "::" , stringify ! ( prop ) ));
}
impl Clone for VREvent_Property_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HiddenAreaMesh_t {
    pub pVertexData: *mut HmdVector2_t,
    pub unTriangleCount: u32,
}
#[test]
fn bindgen_test_layout_HiddenAreaMesh_t() {
    assert_eq!(::std::mem::size_of::<HiddenAreaMesh_t>() , 16usize , concat !
               ( "Size of: " , stringify ! ( HiddenAreaMesh_t ) ));
    assert_eq! (::std::mem::align_of::<HiddenAreaMesh_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( HiddenAreaMesh_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HiddenAreaMesh_t ) ) . pVertexData as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( HiddenAreaMesh_t ) ,
                "::" , stringify ! ( pVertexData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const HiddenAreaMesh_t ) ) . unTriangleCount as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( HiddenAreaMesh_t ) ,
                "::" , stringify ! ( unTriangleCount ) ));
}
impl Clone for HiddenAreaMesh_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VRControllerAxis_t {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_VRControllerAxis_t() {
    assert_eq!(::std::mem::size_of::<VRControllerAxis_t>() , 8usize , concat !
               ( "Size of: " , stringify ! ( VRControllerAxis_t ) ));
    assert_eq! (::std::mem::align_of::<VRControllerAxis_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VRControllerAxis_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRControllerAxis_t ) ) . x as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VRControllerAxis_t ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRControllerAxis_t ) ) . y as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VRControllerAxis_t ) ,
                "::" , stringify ! ( y ) ));
}
impl Clone for VRControllerAxis_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VRControllerState_t {
    pub unPacketNum: u32,
    pub ulButtonPressed: u64,
    pub ulButtonTouched: u64,
    pub rAxis: [VRControllerAxis_t; 5usize],
}
#[test]
fn bindgen_test_layout_VRControllerState_t() {
    assert_eq!(::std::mem::size_of::<VRControllerState_t>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( VRControllerState_t ) ));
    assert_eq! (::std::mem::align_of::<VRControllerState_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VRControllerState_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRControllerState_t ) ) . unPacketNum as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VRControllerState_t ) ,
                "::" , stringify ! ( unPacketNum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRControllerState_t ) ) . ulButtonPressed
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VRControllerState_t ) ,
                "::" , stringify ! ( ulButtonPressed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRControllerState_t ) ) . ulButtonTouched
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VRControllerState_t ) ,
                "::" , stringify ! ( ulButtonTouched ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VRControllerState_t ) ) . rAxis as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VRControllerState_t ) ,
                "::" , stringify ! ( rAxis ) ));
}
impl Clone for VRControllerState_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Compositor_OverlaySettings {
    pub size: u32,
    pub curved: bool,
    pub antialias: bool,
    pub scale: f32,
    pub distance: f32,
    pub alpha: f32,
    pub uOffset: f32,
    pub vOffset: f32,
    pub uScale: f32,
    pub vScale: f32,
    pub gridDivs: f32,
    pub gridWidth: f32,
    pub gridScale: f32,
    pub transform: HmdMatrix44_t,
}
#[test]
fn bindgen_test_layout_Compositor_OverlaySettings() {
    assert_eq!(::std::mem::size_of::<Compositor_OverlaySettings>() , 112usize
               , concat ! (
               "Size of: " , stringify ! ( Compositor_OverlaySettings ) ));
    assert_eq! (::std::mem::align_of::<Compositor_OverlaySettings>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( Compositor_OverlaySettings )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) . size as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) . curved
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( curved )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) .
                antialias as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( antialias
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) . scale as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( scale )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) . distance
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( distance )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) . alpha as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( alpha )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) . uOffset
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( uOffset )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) . vOffset
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( vOffset )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) . uScale
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( uScale )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) . vScale
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( vScale )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) . gridDivs
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( gridDivs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) .
                gridWidth as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( gridWidth
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) .
                gridScale as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( gridScale
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_OverlaySettings ) ) .
                transform as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_OverlaySettings ) , "::" , stringify ! ( transform
                ) ));
}
impl Clone for Compositor_OverlaySettings {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CameraVideoStreamFrameHeader_t {
    pub eFrameType: EVRTrackedCameraFrameType,
    pub nWidth: u32,
    pub nHeight: u32,
    pub nBytesPerPixel: u32,
    pub nFrameSequence: u32,
    pub standingTrackedDevicePose: TrackedDevicePose_t,
}
#[test]
fn bindgen_test_layout_CameraVideoStreamFrameHeader_t() {
    assert_eq!(::std::mem::size_of::<CameraVideoStreamFrameHeader_t>() ,
               100usize , concat ! (
               "Size of: " , stringify ! ( CameraVideoStreamFrameHeader_t )
               ));
    assert_eq! (::std::mem::align_of::<CameraVideoStreamFrameHeader_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( CameraVideoStreamFrameHeader_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CameraVideoStreamFrameHeader_t ) ) .
                eFrameType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CameraVideoStreamFrameHeader_t ) , "::" , stringify ! (
                eFrameType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CameraVideoStreamFrameHeader_t ) ) .
                nWidth as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CameraVideoStreamFrameHeader_t ) , "::" , stringify ! ( nWidth
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CameraVideoStreamFrameHeader_t ) ) .
                nHeight as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CameraVideoStreamFrameHeader_t ) , "::" , stringify ! (
                nHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CameraVideoStreamFrameHeader_t ) ) .
                nBytesPerPixel as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                CameraVideoStreamFrameHeader_t ) , "::" , stringify ! (
                nBytesPerPixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CameraVideoStreamFrameHeader_t ) ) .
                nFrameSequence as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                CameraVideoStreamFrameHeader_t ) , "::" , stringify ! (
                nFrameSequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CameraVideoStreamFrameHeader_t ) ) .
                standingTrackedDevicePose as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                CameraVideoStreamFrameHeader_t ) , "::" , stringify ! (
                standingTrackedDevicePose ) ));
}
impl Clone for CameraVideoStreamFrameHeader_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AppOverrideKeys_t {
    pub pchKey: *mut ::std::os::raw::c_char,
    pub pchValue: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AppOverrideKeys_t() {
    assert_eq!(::std::mem::size_of::<AppOverrideKeys_t>() , 16usize , concat !
               ( "Size of: " , stringify ! ( AppOverrideKeys_t ) ));
    assert_eq! (::std::mem::align_of::<AppOverrideKeys_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AppOverrideKeys_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppOverrideKeys_t ) ) . pchKey as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AppOverrideKeys_t ) ,
                "::" , stringify ! ( pchKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AppOverrideKeys_t ) ) . pchValue as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AppOverrideKeys_t ) ,
                "::" , stringify ! ( pchValue ) ));
}
impl Clone for AppOverrideKeys_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Compositor_FrameTiming {
    pub m_nSize: u32,
    pub m_nFrameIndex: u32,
    pub m_nNumFramePresents: u32,
    pub m_nNumMisPresented: u32,
    pub m_nNumDroppedFrames: u32,
    pub m_nReprojectionFlags: u32,
    pub m_flSystemTimeInSeconds: f64,
    pub m_flPreSubmitGpuMs: f32,
    pub m_flPostSubmitGpuMs: f32,
    pub m_flTotalRenderGpuMs: f32,
    pub m_flCompositorRenderGpuMs: f32,
    pub m_flCompositorRenderCpuMs: f32,
    pub m_flCompositorIdleCpuMs: f32,
    pub m_flClientFrameIntervalMs: f32,
    pub m_flPresentCallCpuMs: f32,
    pub m_flWaitForPresentCpuMs: f32,
    pub m_flSubmitFrameMs: f32,
    pub m_flWaitGetPosesCalledMs: f32,
    pub m_flNewPosesReadyMs: f32,
    pub m_flNewFrameReadyMs: f32,
    pub m_flCompositorUpdateStartMs: f32,
    pub m_flCompositorUpdateEndMs: f32,
    pub m_flCompositorRenderStartMs: f32,
    pub m_HmdPose: TrackedDevicePose_t,
}
#[test]
fn bindgen_test_layout_Compositor_FrameTiming() {
    assert_eq!(::std::mem::size_of::<Compositor_FrameTiming>() , 176usize ,
               concat ! ( "Size of: " , stringify ! ( Compositor_FrameTiming )
               ));
    assert_eq! (::std::mem::align_of::<Compositor_FrameTiming>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Compositor_FrameTiming ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) . m_nSize as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_nSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_nFrameIndex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_nFrameIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_nNumFramePresents as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_nNumFramePresents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_nNumMisPresented as * const _ as usize } , 12usize , concat
                ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_nNumMisPresented ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_nNumDroppedFrames as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_nNumDroppedFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_nReprojectionFlags as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_nReprojectionFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flSystemTimeInSeconds as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flSystemTimeInSeconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flPreSubmitGpuMs as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flPreSubmitGpuMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flPostSubmitGpuMs as * const _ as usize } , 36usize , concat
                ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flPostSubmitGpuMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flTotalRenderGpuMs as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flTotalRenderGpuMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flCompositorRenderGpuMs as * const _ as usize } , 44usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flCompositorRenderGpuMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flCompositorRenderCpuMs as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flCompositorRenderCpuMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flCompositorIdleCpuMs as * const _ as usize } , 52usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flCompositorIdleCpuMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flClientFrameIntervalMs as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flClientFrameIntervalMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flPresentCallCpuMs as * const _ as usize } , 60usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flPresentCallCpuMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flWaitForPresentCpuMs as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flWaitForPresentCpuMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flSubmitFrameMs as * const _ as usize } , 68usize , concat !
                (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flSubmitFrameMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flWaitGetPosesCalledMs as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flWaitGetPosesCalledMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flNewPosesReadyMs as * const _ as usize } , 76usize , concat
                ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flNewPosesReadyMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flNewFrameReadyMs as * const _ as usize } , 80usize , concat
                ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flNewFrameReadyMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flCompositorUpdateStartMs as * const _ as usize } , 84usize
                , concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flCompositorUpdateStartMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flCompositorUpdateEndMs as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flCompositorUpdateEndMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) .
                m_flCompositorRenderStartMs as * const _ as usize } , 92usize
                , concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_flCompositorRenderStartMs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_FrameTiming ) ) . m_HmdPose as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( Compositor_FrameTiming
                ) , "::" , stringify ! ( m_HmdPose ) ));
}
impl Clone for Compositor_FrameTiming {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Compositor_CumulativeStats {
    pub m_nPid: u32,
    pub m_nNumFramePresents: u32,
    pub m_nNumDroppedFrames: u32,
    pub m_nNumReprojectedFrames: u32,
    pub m_nNumFramePresentsOnStartup: u32,
    pub m_nNumDroppedFramesOnStartup: u32,
    pub m_nNumReprojectedFramesOnStartup: u32,
    pub m_nNumLoading: u32,
    pub m_nNumFramePresentsLoading: u32,
    pub m_nNumDroppedFramesLoading: u32,
    pub m_nNumReprojectedFramesLoading: u32,
    pub m_nNumTimedOut: u32,
    pub m_nNumFramePresentsTimedOut: u32,
    pub m_nNumDroppedFramesTimedOut: u32,
    pub m_nNumReprojectedFramesTimedOut: u32,
}
#[test]
fn bindgen_test_layout_Compositor_CumulativeStats() {
    assert_eq!(::std::mem::size_of::<Compositor_CumulativeStats>() , 60usize ,
               concat ! (
               "Size of: " , stringify ! ( Compositor_CumulativeStats ) ));
    assert_eq! (::std::mem::align_of::<Compositor_CumulativeStats>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( Compositor_CumulativeStats )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) . m_nPid
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! ( m_nPid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumFramePresents as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumFramePresents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumDroppedFrames as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumDroppedFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumReprojectedFrames as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumReprojectedFrames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumFramePresentsOnStartup as * const _ as usize } , 16usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumFramePresentsOnStartup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumDroppedFramesOnStartup as * const _ as usize } , 20usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumDroppedFramesOnStartup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumReprojectedFramesOnStartup as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumReprojectedFramesOnStartup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumLoading as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumLoading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumFramePresentsLoading as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumFramePresentsLoading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumDroppedFramesLoading as * const _ as usize } , 36usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumDroppedFramesLoading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumReprojectedFramesLoading as * const _ as usize } ,
                40usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumReprojectedFramesLoading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumTimedOut as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumTimedOut ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumFramePresentsTimedOut as * const _ as usize } , 48usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumFramePresentsTimedOut ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumDroppedFramesTimedOut as * const _ as usize } , 52usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumDroppedFramesTimedOut ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Compositor_CumulativeStats ) ) .
                m_nNumReprojectedFramesTimedOut as * const _ as usize } ,
                56usize , concat ! (
                "Alignment of field: " , stringify ! (
                Compositor_CumulativeStats ) , "::" , stringify ! (
                m_nNumReprojectedFramesTimedOut ) ));
}
impl Clone for Compositor_CumulativeStats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VROverlayIntersectionParams_t {
    pub vSource: HmdVector3_t,
    pub vDirection: HmdVector3_t,
    pub eOrigin: ETrackingUniverseOrigin,
}
#[test]
fn bindgen_test_layout_VROverlayIntersectionParams_t() {
    assert_eq!(::std::mem::size_of::<VROverlayIntersectionParams_t>() ,
               28usize , concat ! (
               "Size of: " , stringify ! ( VROverlayIntersectionParams_t ) ));
    assert_eq! (::std::mem::align_of::<VROverlayIntersectionParams_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( VROverlayIntersectionParams_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VROverlayIntersectionParams_t ) ) .
                vSource as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionParams_t ) , "::" , stringify ! ( vSource
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VROverlayIntersectionParams_t ) ) .
                vDirection as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionParams_t ) , "::" , stringify ! (
                vDirection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VROverlayIntersectionParams_t ) ) .
                eOrigin as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionParams_t ) , "::" , stringify ! ( eOrigin
                ) ));
}
impl Clone for VROverlayIntersectionParams_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VROverlayIntersectionResults_t {
    pub vPoint: HmdVector3_t,
    pub vNormal: HmdVector3_t,
    pub vUVs: HmdVector2_t,
    pub fDistance: f32,
}
#[test]
fn bindgen_test_layout_VROverlayIntersectionResults_t() {
    assert_eq!(::std::mem::size_of::<VROverlayIntersectionResults_t>() ,
               36usize , concat ! (
               "Size of: " , stringify ! ( VROverlayIntersectionResults_t )
               ));
    assert_eq! (::std::mem::align_of::<VROverlayIntersectionResults_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( VROverlayIntersectionResults_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VROverlayIntersectionResults_t ) ) .
                vPoint as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionResults_t ) , "::" , stringify ! ( vPoint
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VROverlayIntersectionResults_t ) ) .
                vNormal as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionResults_t ) , "::" , stringify ! (
                vNormal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VROverlayIntersectionResults_t ) ) . vUVs
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionResults_t ) , "::" , stringify ! ( vUVs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VROverlayIntersectionResults_t ) ) .
                fDistance as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionResults_t ) , "::" , stringify ! (
                fDistance ) ));
}
impl Clone for VROverlayIntersectionResults_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IntersectionMaskRectangle_t {
    pub m_flTopLeftX: f32,
    pub m_flTopLeftY: f32,
    pub m_flWidth: f32,
    pub m_flHeight: f32,
}
#[test]
fn bindgen_test_layout_IntersectionMaskRectangle_t() {
    assert_eq!(::std::mem::size_of::<IntersectionMaskRectangle_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( IntersectionMaskRectangle_t ) ));
    assert_eq! (::std::mem::align_of::<IntersectionMaskRectangle_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( IntersectionMaskRectangle_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntersectionMaskRectangle_t ) ) .
                m_flTopLeftX as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                IntersectionMaskRectangle_t ) , "::" , stringify ! (
                m_flTopLeftX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntersectionMaskRectangle_t ) ) .
                m_flTopLeftY as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                IntersectionMaskRectangle_t ) , "::" , stringify ! (
                m_flTopLeftY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntersectionMaskRectangle_t ) ) .
                m_flWidth as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                IntersectionMaskRectangle_t ) , "::" , stringify ! ( m_flWidth
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntersectionMaskRectangle_t ) ) .
                m_flHeight as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                IntersectionMaskRectangle_t ) , "::" , stringify ! (
                m_flHeight ) ));
}
impl Clone for IntersectionMaskRectangle_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IntersectionMaskCircle_t {
    pub m_flCenterX: f32,
    pub m_flCenterY: f32,
    pub m_flRadius: f32,
}
#[test]
fn bindgen_test_layout_IntersectionMaskCircle_t() {
    assert_eq!(::std::mem::size_of::<IntersectionMaskCircle_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( IntersectionMaskCircle_t ) ));
    assert_eq! (::std::mem::align_of::<IntersectionMaskCircle_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( IntersectionMaskCircle_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntersectionMaskCircle_t ) ) .
                m_flCenterX as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                IntersectionMaskCircle_t ) , "::" , stringify ! ( m_flCenterX
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntersectionMaskCircle_t ) ) .
                m_flCenterY as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                IntersectionMaskCircle_t ) , "::" , stringify ! ( m_flCenterY
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const IntersectionMaskCircle_t ) ) . m_flRadius
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                IntersectionMaskCircle_t ) , "::" , stringify ! ( m_flRadius )
                ));
}
impl Clone for IntersectionMaskCircle_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RenderModel_ComponentState_t {
    pub mTrackingToComponentRenderModel: HmdMatrix34_t,
    pub mTrackingToComponentLocal: HmdMatrix34_t,
    pub uProperties: VRComponentProperties,
}
#[test]
fn bindgen_test_layout_RenderModel_ComponentState_t() {
    assert_eq!(::std::mem::size_of::<RenderModel_ComponentState_t>() ,
               100usize , concat ! (
               "Size of: " , stringify ! ( RenderModel_ComponentState_t ) ));
    assert_eq! (::std::mem::align_of::<RenderModel_ComponentState_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( RenderModel_ComponentState_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_ComponentState_t ) ) .
                mTrackingToComponentRenderModel as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! (
                RenderModel_ComponentState_t ) , "::" , stringify ! (
                mTrackingToComponentRenderModel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_ComponentState_t ) ) .
                mTrackingToComponentLocal as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                RenderModel_ComponentState_t ) , "::" , stringify ! (
                mTrackingToComponentLocal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_ComponentState_t ) ) .
                uProperties as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                RenderModel_ComponentState_t ) , "::" , stringify ! (
                uProperties ) ));
}
impl Clone for RenderModel_ComponentState_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RenderModel_Vertex_t {
    pub vPosition: HmdVector3_t,
    pub vNormal: HmdVector3_t,
    pub rfTextureCoord: [f32; 2usize],
}
#[test]
fn bindgen_test_layout_RenderModel_Vertex_t() {
    assert_eq!(::std::mem::size_of::<RenderModel_Vertex_t>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( RenderModel_Vertex_t )
               ));
    assert_eq! (::std::mem::align_of::<RenderModel_Vertex_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( RenderModel_Vertex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_Vertex_t ) ) . vPosition as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderModel_Vertex_t )
                , "::" , stringify ! ( vPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_Vertex_t ) ) . vNormal as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderModel_Vertex_t )
                , "::" , stringify ! ( vNormal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_Vertex_t ) ) . rfTextureCoord
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderModel_Vertex_t )
                , "::" , stringify ! ( rfTextureCoord ) ));
}
impl Clone for RenderModel_Vertex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RenderModel_TextureMap_t {
    pub unWidth: u16,
    pub unHeight: u16,
    pub rubTextureMapData: *mut u8,
}
#[test]
fn bindgen_test_layout_RenderModel_TextureMap_t() {
    assert_eq!(::std::mem::size_of::<RenderModel_TextureMap_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( RenderModel_TextureMap_t ) ));
    assert_eq! (::std::mem::align_of::<RenderModel_TextureMap_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( RenderModel_TextureMap_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_TextureMap_t ) ) . unWidth as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                RenderModel_TextureMap_t ) , "::" , stringify ! ( unWidth )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_TextureMap_t ) ) . unHeight
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                RenderModel_TextureMap_t ) , "::" , stringify ! ( unHeight )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_TextureMap_t ) ) .
                rubTextureMapData as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! (
                RenderModel_TextureMap_t ) , "::" , stringify ! (
                rubTextureMapData ) ));
}
impl Clone for RenderModel_TextureMap_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RenderModel_t {
    pub rVertexData: *mut RenderModel_Vertex_t,
    pub unVertexCount: u32,
    pub rIndexData: *mut u16,
    pub unTriangleCount: u32,
    pub diffuseTextureId: TextureID_t,
}
#[test]
fn bindgen_test_layout_RenderModel_t() {
    assert_eq!(::std::mem::size_of::<RenderModel_t>() , 28usize , concat ! (
               "Size of: " , stringify ! ( RenderModel_t ) ));
    assert_eq! (::std::mem::align_of::<RenderModel_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( RenderModel_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_t ) ) . rVertexData as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderModel_t ) , "::"
                , stringify ! ( rVertexData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_t ) ) . unVertexCount as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderModel_t ) , "::"
                , stringify ! ( unVertexCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_t ) ) . rIndexData as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderModel_t ) , "::"
                , stringify ! ( rIndexData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_t ) ) . unTriangleCount as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderModel_t ) , "::"
                , stringify ! ( unTriangleCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_t ) ) . diffuseTextureId as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RenderModel_t ) , "::"
                , stringify ! ( diffuseTextureId ) ));
}
impl Clone for RenderModel_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RenderModel_ControllerMode_State_t {
    pub bScrollWheelVisible: bool,
}
#[test]
fn bindgen_test_layout_RenderModel_ControllerMode_State_t() {
    assert_eq!(::std::mem::size_of::<RenderModel_ControllerMode_State_t>() ,
               1usize , concat ! (
               "Size of: " , stringify ! ( RenderModel_ControllerMode_State_t
               ) ));
    assert_eq! (::std::mem::align_of::<RenderModel_ControllerMode_State_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                RenderModel_ControllerMode_State_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RenderModel_ControllerMode_State_t ) ) .
                bScrollWheelVisible as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                RenderModel_ControllerMode_State_t ) , "::" , stringify ! (
                bScrollWheelVisible ) ));
}
impl Clone for RenderModel_ControllerMode_State_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NotificationBitmap_t {
    pub m_pImageData: *mut ::std::os::raw::c_void,
    pub m_nWidth: i32,
    pub m_nHeight: i32,
    pub m_nBytesPerPixel: i32,
}
#[test]
fn bindgen_test_layout_NotificationBitmap_t() {
    assert_eq!(::std::mem::size_of::<NotificationBitmap_t>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( NotificationBitmap_t )
               ));
    assert_eq! (::std::mem::align_of::<NotificationBitmap_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( NotificationBitmap_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NotificationBitmap_t ) ) . m_pImageData
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( NotificationBitmap_t )
                , "::" , stringify ! ( m_pImageData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NotificationBitmap_t ) ) . m_nWidth as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( NotificationBitmap_t )
                , "::" , stringify ! ( m_nWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NotificationBitmap_t ) ) . m_nHeight as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( NotificationBitmap_t )
                , "::" , stringify ! ( m_nHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const NotificationBitmap_t ) ) .
                m_nBytesPerPixel as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( NotificationBitmap_t )
                , "::" , stringify ! ( m_nBytesPerPixel ) ));
}
impl Clone for NotificationBitmap_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct COpenVRContext {
    pub m_pVRSystem: isize,
    pub m_pVRChaperone: isize,
    pub m_pVRChaperoneSetup: isize,
    pub m_pVRCompositor: isize,
    pub m_pVROverlay: isize,
    pub m_pVRResources: isize,
    pub m_pVRRenderModels: isize,
    pub m_pVRExtendedDisplay: isize,
    pub m_pVRSettings: isize,
    pub m_pVRApplications: isize,
    pub m_pVRTrackedCamera: isize,
    pub m_pVRScreenshots: isize,
    pub m_pVRDriverManager: isize,
}
#[test]
fn bindgen_test_layout_COpenVRContext() {
    assert_eq!(::std::mem::size_of::<COpenVRContext>() , 104usize , concat ! (
               "Size of: " , stringify ! ( COpenVRContext ) ));
    assert_eq! (::std::mem::align_of::<COpenVRContext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( COpenVRContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRSystem as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRSystem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRChaperone as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRChaperone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRChaperoneSetup
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRChaperoneSetup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRCompositor as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRCompositor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVROverlay as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVROverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRResources as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRResources ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRRenderModels as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRRenderModels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRExtendedDisplay
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRExtendedDisplay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRSettings as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRSettings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRApplications as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRApplications ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRTrackedCamera
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRTrackedCamera ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRScreenshots as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRScreenshots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const COpenVRContext ) ) . m_pVRDriverManager
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( COpenVRContext ) , "::"
                , stringify ! ( m_pVRDriverManager ) ));
}
impl Clone for COpenVRContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Data_t {
    pub reserved: __BindgenUnionField<VREvent_Reserved_t>,
    pub controller: __BindgenUnionField<VREvent_Controller_t>,
    pub mouse: __BindgenUnionField<VREvent_Mouse_t>,
    pub scroll: __BindgenUnionField<VREvent_Scroll_t>,
    pub process: __BindgenUnionField<VREvent_Process_t>,
    pub notification: __BindgenUnionField<VREvent_Notification_t>,
    pub overlay: __BindgenUnionField<VREvent_Overlay_t>,
    pub status: __BindgenUnionField<VREvent_Status_t>,
    pub keyboard: __BindgenUnionField<VREvent_Keyboard_t>,
    pub ipd: __BindgenUnionField<VREvent_Ipd_t>,
    pub chaperone: __BindgenUnionField<VREvent_Chaperone_t>,
    pub performanceTest: __BindgenUnionField<VREvent_PerformanceTest_t>,
    pub touchPadMove: __BindgenUnionField<VREvent_TouchPadMove_t>,
    pub seatedZeroPoseReset: __BindgenUnionField<VREvent_SeatedZeroPoseReset_t>,
    pub bindgen_union_field: [u64; 9usize],
}
#[test]
fn bindgen_test_layout_VREvent_Data_t() {
    assert_eq!(::std::mem::size_of::<VREvent_Data_t>() , 72usize , concat ! (
               "Size of: " , stringify ! ( VREvent_Data_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Data_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VREvent_Data_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . reserved as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . controller as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( controller ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . mouse as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( mouse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . scroll as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( scroll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . process as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( process ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . notification as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( notification ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . overlay as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( overlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . status as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . keyboard as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( keyboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . ipd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( ipd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . chaperone as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( chaperone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . performanceTest as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( performanceTest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . touchPadMove as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( touchPadMove ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Data_t ) ) . seatedZeroPoseReset
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Data_t ) , "::"
                , stringify ! ( seatedZeroPoseReset ) ));
}
impl Clone for VREvent_Data_t {
    fn clone(&self) -> Self { *self }
}
/** An event posted by the server to all running applications */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_t {
    pub eventType: u32,
    pub trackedDeviceIndex: TrackedDeviceIndex_t,
    pub eventAgeSeconds: f32,
    pub data: VREvent_Data_t,
}
#[test]
fn bindgen_test_layout_VREvent_t() {
    assert_eq!(::std::mem::size_of::<VREvent_t>() , 88usize , concat ! (
               "Size of: " , stringify ! ( VREvent_t ) ));
    assert_eq! (::std::mem::align_of::<VREvent_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VREvent_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_t ) ) . eventType as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_t ) , "::" ,
                stringify ! ( eventType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_t ) ) . trackedDeviceIndex as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_t ) , "::" ,
                stringify ! ( trackedDeviceIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_t ) ) . eventAgeSeconds as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_t ) , "::" ,
                stringify ! ( eventAgeSeconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_t ) ) . data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_t ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for VREvent_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VROverlayIntersectionMaskPrimitive_Data_t {
    pub m_Rectangle: __BindgenUnionField<IntersectionMaskRectangle_t>,
    pub m_Circle: __BindgenUnionField<IntersectionMaskCircle_t>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_VROverlayIntersectionMaskPrimitive_Data_t() {
    assert_eq!(::std::mem::size_of::<VROverlayIntersectionMaskPrimitive_Data_t>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               VROverlayIntersectionMaskPrimitive_Data_t ) ));
    assert_eq! (::std::mem::align_of::<VROverlayIntersectionMaskPrimitive_Data_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                VROverlayIntersectionMaskPrimitive_Data_t ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VROverlayIntersectionMaskPrimitive_Data_t ) )
                . m_Rectangle as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionMaskPrimitive_Data_t ) , "::" , stringify
                ! ( m_Rectangle ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VROverlayIntersectionMaskPrimitive_Data_t ) )
                . m_Circle as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionMaskPrimitive_Data_t ) , "::" , stringify
                ! ( m_Circle ) ));
}
impl Clone for VROverlayIntersectionMaskPrimitive_Data_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VROverlayIntersectionMaskPrimitive_t {
    pub m_nPrimitiveType: EVROverlayIntersectionMaskPrimitiveType,
    pub m_Primitive: VROverlayIntersectionMaskPrimitive_Data_t,
}
#[test]
fn bindgen_test_layout_VROverlayIntersectionMaskPrimitive_t() {
    assert_eq!(::std::mem::size_of::<VROverlayIntersectionMaskPrimitive_t>() ,
               20usize , concat ! (
               "Size of: " , stringify ! (
               VROverlayIntersectionMaskPrimitive_t ) ));
    assert_eq! (::std::mem::align_of::<VROverlayIntersectionMaskPrimitive_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                VROverlayIntersectionMaskPrimitive_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VROverlayIntersectionMaskPrimitive_t ) )
                . m_nPrimitiveType as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionMaskPrimitive_t ) , "::" , stringify ! (
                m_nPrimitiveType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VROverlayIntersectionMaskPrimitive_t ) )
                . m_Primitive as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VROverlayIntersectionMaskPrimitive_t ) , "::" , stringify ! (
                m_Primitive ) ));
}
impl Clone for VROverlayIntersectionMaskPrimitive_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRSystem_FnTable {
    pub GetRecommendedRenderTargetSize: ::std::option::Option<unsafe extern "C" fn(pnWidth:
                                                                                       *mut u32,
                                                                                   pnHeight:
                                                                                       *mut u32)>,
    pub GetProjectionMatrix: ::std::option::Option<unsafe extern "C" fn(eEye:
                                                                            EVREye,
                                                                        fNearZ:
                                                                            f32,
                                                                        fFarZ:
                                                                            f32)
                                                       -> HmdMatrix44_t>,
    pub GetProjectionRaw: ::std::option::Option<unsafe extern "C" fn(eEye:
                                                                         EVREye,
                                                                     pfLeft:
                                                                         *mut f32,
                                                                     pfRight:
                                                                         *mut f32,
                                                                     pfTop:
                                                                         *mut f32,
                                                                     pfBottom:
                                                                         *mut f32)>,
    pub ComputeDistortion: ::std::option::Option<unsafe extern "C" fn(eEye:
                                                                          EVREye,
                                                                      fU: f32,
                                                                      fV: f32,
                                                                      pDistortionCoordinates:
                                                                          *mut DistortionCoordinates_t)
                                                     -> bool>,
    pub GetEyeToHeadTransform: ::std::option::Option<unsafe extern "C" fn(eEye:
                                                                              EVREye)
                                                         -> HmdMatrix34_t>,
    pub GetTimeSinceLastVsync: ::std::option::Option<unsafe extern "C" fn(pfSecondsSinceLastVsync:
                                                                              *mut f32,
                                                                          pulFrameCounter:
                                                                              *mut u64)
                                                         -> bool>,
    pub GetD3D9AdapterIndex: ::std::option::Option<unsafe extern "C" fn()
                                                       -> i32>,
    pub GetDXGIOutputInfo: ::std::option::Option<unsafe extern "C" fn(pnAdapterIndex:
                                                                          *mut i32)>,
    pub GetOutputDevice: ::std::option::Option<unsafe extern "C" fn(pnDevice:
                                                                        *mut u64,
                                                                    textureType:
                                                                        ETextureType)>,
    pub IsDisplayOnDesktop: ::std::option::Option<unsafe extern "C" fn()
                                                      -> bool>,
    pub SetDisplayVisibility: ::std::option::Option<unsafe extern "C" fn(bIsVisibleOnDesktop:
                                                                             bool)
                                                        -> bool>,
    pub GetDeviceToAbsoluteTrackingPose: ::std::option::Option<unsafe extern "C" fn(eOrigin:
                                                                                        ETrackingUniverseOrigin,
                                                                                    fPredictedSecondsToPhotonsFromNow:
                                                                                        f32,
                                                                                    pTrackedDevicePoseArray:
                                                                                        *mut TrackedDevicePose_t,
                                                                                    unTrackedDevicePoseArrayCount:
                                                                                        u32)>,
    pub ResetSeatedZeroPose: ::std::option::Option<unsafe extern "C" fn()>,
    pub GetSeatedZeroPoseToStandingAbsoluteTrackingPose: ::std::option::Option<unsafe extern "C" fn()
                                                                                   ->
                                                                                       HmdMatrix34_t>,
    pub GetRawZeroPoseToStandingAbsoluteTrackingPose: ::std::option::Option<unsafe extern "C" fn()
                                                                                ->
                                                                                    HmdMatrix34_t>,
    pub GetSortedTrackedDeviceIndicesOfClass: ::std::option::Option<unsafe extern "C" fn(eTrackedDeviceClass:
                                                                                             ETrackedDeviceClass,
                                                                                         punTrackedDeviceIndexArray:
                                                                                             *mut TrackedDeviceIndex_t,
                                                                                         unTrackedDeviceIndexArrayCount:
                                                                                             u32,
                                                                                         unRelativeToTrackedDeviceIndex:
                                                                                             TrackedDeviceIndex_t)
                                                                        ->
                                                                            u32>,
    pub GetTrackedDeviceActivityLevel: ::std::option::Option<unsafe extern "C" fn(unDeviceId:
                                                                                      TrackedDeviceIndex_t)
                                                                 ->
                                                                     EDeviceActivityLevel>,
    pub ApplyTransform: ::std::option::Option<unsafe extern "C" fn(pOutputPose:
                                                                       *mut TrackedDevicePose_t,
                                                                   pTrackedDevicePose:
                                                                       *mut TrackedDevicePose_t,
                                                                   pTransform:
                                                                       *mut HmdMatrix34_t)>,
    pub GetTrackedDeviceIndexForControllerRole: ::std::option::Option<unsafe extern "C" fn(unDeviceType:
                                                                                               ETrackedControllerRole)
                                                                          ->
                                                                              TrackedDeviceIndex_t>,
    pub GetControllerRoleForTrackedDeviceIndex: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                                               TrackedDeviceIndex_t)
                                                                          ->
                                                                              ETrackedControllerRole>,
    pub GetTrackedDeviceClass: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                              TrackedDeviceIndex_t)
                                                         ->
                                                             ETrackedDeviceClass>,
    pub IsTrackedDeviceConnected: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                                 TrackedDeviceIndex_t)
                                                            -> bool>,
    pub GetBoolTrackedDeviceProperty: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                                     TrackedDeviceIndex_t,
                                                                                 prop:
                                                                                     ETrackedDeviceProperty,
                                                                                 pError:
                                                                                     *mut ETrackedPropertyError)
                                                                -> bool>,
    pub GetFloatTrackedDeviceProperty: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                                      TrackedDeviceIndex_t,
                                                                                  prop:
                                                                                      ETrackedDeviceProperty,
                                                                                  pError:
                                                                                      *mut ETrackedPropertyError)
                                                                 -> f32>,
    pub GetInt32TrackedDeviceProperty: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                                      TrackedDeviceIndex_t,
                                                                                  prop:
                                                                                      ETrackedDeviceProperty,
                                                                                  pError:
                                                                                      *mut ETrackedPropertyError)
                                                                 -> i32>,
    pub GetUint64TrackedDeviceProperty: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                                       TrackedDeviceIndex_t,
                                                                                   prop:
                                                                                       ETrackedDeviceProperty,
                                                                                   pError:
                                                                                       *mut ETrackedPropertyError)
                                                                  -> u64>,
    pub GetMatrix34TrackedDeviceProperty: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                                         TrackedDeviceIndex_t,
                                                                                     prop:
                                                                                         ETrackedDeviceProperty,
                                                                                     pError:
                                                                                         *mut ETrackedPropertyError)
                                                                    ->
                                                                        HmdMatrix34_t>,
    pub GetStringTrackedDeviceProperty: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                                       TrackedDeviceIndex_t,
                                                                                   prop:
                                                                                       ETrackedDeviceProperty,
                                                                                   pchValue:
                                                                                       *mut ::std::os::raw::c_char,
                                                                                   unBufferSize:
                                                                                       u32,
                                                                                   pError:
                                                                                       *mut ETrackedPropertyError)
                                                                  -> u32>,
    pub GetPropErrorNameFromEnum: ::std::option::Option<unsafe extern "C" fn(error:
                                                                                 ETrackedPropertyError)
                                                            ->
                                                                *mut ::std::os::raw::c_char>,
    pub PollNextEvent: ::std::option::Option<unsafe extern "C" fn(pEvent:
                                                                      *mut VREvent_t,
                                                                  uncbVREvent:
                                                                      u32)
                                                 -> bool>,
    pub PollNextEventWithPose: ::std::option::Option<unsafe extern "C" fn(eOrigin:
                                                                              ETrackingUniverseOrigin,
                                                                          pEvent:
                                                                              *mut VREvent_t,
                                                                          uncbVREvent:
                                                                              u32,
                                                                          pTrackedDevicePose:
                                                                              *mut TrackedDevicePose_t)
                                                         -> bool>,
    pub GetEventTypeNameFromEnum: ::std::option::Option<unsafe extern "C" fn(eType:
                                                                                 EVREventType)
                                                            ->
                                                                *mut ::std::os::raw::c_char>,
    pub GetHiddenAreaMesh: ::std::option::Option<unsafe extern "C" fn(eEye:
                                                                          EVREye,
                                                                      type_:
                                                                          EHiddenAreaMeshType)
                                                     -> HiddenAreaMesh_t>,
    pub GetControllerState: ::std::option::Option<unsafe extern "C" fn(unControllerDeviceIndex:
                                                                           TrackedDeviceIndex_t,
                                                                       pControllerState:
                                                                           *mut VRControllerState_t,
                                                                       unControllerStateSize:
                                                                           u32)
                                                      -> bool>,
    pub GetControllerStateWithPose: ::std::option::Option<unsafe extern "C" fn(eOrigin:
                                                                                   ETrackingUniverseOrigin,
                                                                               unControllerDeviceIndex:
                                                                                   TrackedDeviceIndex_t,
                                                                               pControllerState:
                                                                                   *mut VRControllerState_t,
                                                                               unControllerStateSize:
                                                                                   u32,
                                                                               pTrackedDevicePose:
                                                                                   *mut TrackedDevicePose_t)
                                                              -> bool>,
    pub TriggerHapticPulse: ::std::option::Option<unsafe extern "C" fn(unControllerDeviceIndex:
                                                                           TrackedDeviceIndex_t,
                                                                       unAxisId:
                                                                           u32,
                                                                       usDurationMicroSec:
                                                                           ::std::os::raw::c_ushort)>,
    pub GetButtonIdNameFromEnum: ::std::option::Option<unsafe extern "C" fn(eButtonId:
                                                                                EVRButtonId)
                                                           ->
                                                               *mut ::std::os::raw::c_char>,
    pub GetControllerAxisTypeNameFromEnum: ::std::option::Option<unsafe extern "C" fn(eAxisType:
                                                                                          EVRControllerAxisType)
                                                                     ->
                                                                         *mut ::std::os::raw::c_char>,
    pub CaptureInputFocus: ::std::option::Option<unsafe extern "C" fn()
                                                     -> bool>,
    pub ReleaseInputFocus: ::std::option::Option<unsafe extern "C" fn()>,
    pub IsInputFocusCapturedByAnotherProcess: ::std::option::Option<unsafe extern "C" fn()
                                                                        ->
                                                                            bool>,
    pub DriverDebugRequest: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                           TrackedDeviceIndex_t,
                                                                       pchRequest:
                                                                           *mut ::std::os::raw::c_char,
                                                                       pchResponseBuffer:
                                                                           *mut ::std::os::raw::c_char,
                                                                       unResponseBufferSize:
                                                                           u32)
                                                      -> u32>,
    pub PerformFirmwareUpdate: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                              TrackedDeviceIndex_t)
                                                         -> EVRFirmwareError>,
    pub AcknowledgeQuit_Exiting: ::std::option::Option<unsafe extern "C" fn()>,
    pub AcknowledgeQuit_UserPrompt: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_VR_IVRSystem_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRSystem_FnTable>() , 360usize ,
               concat ! ( "Size of: " , stringify ! ( VR_IVRSystem_FnTable )
               ));
    assert_eq! (::std::mem::align_of::<VR_IVRSystem_FnTable>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VR_IVRSystem_FnTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetRecommendedRenderTargetSize as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetRecommendedRenderTargetSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetProjectionMatrix as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetProjectionMatrix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetProjectionRaw as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetProjectionRaw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                ComputeDistortion as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( ComputeDistortion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetEyeToHeadTransform as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetEyeToHeadTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetTimeSinceLastVsync as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetTimeSinceLastVsync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetD3D9AdapterIndex as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetD3D9AdapterIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetDXGIOutputInfo as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetDXGIOutputInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetOutputDevice as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetOutputDevice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                IsDisplayOnDesktop as * const _ as usize } , 72usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( IsDisplayOnDesktop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                SetDisplayVisibility as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( SetDisplayVisibility ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetDeviceToAbsoluteTrackingPose as * const _ as usize } ,
                88usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetDeviceToAbsoluteTrackingPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                ResetSeatedZeroPose as * const _ as usize } , 96usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( ResetSeatedZeroPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetSeatedZeroPoseToStandingAbsoluteTrackingPose as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! (
                GetSeatedZeroPoseToStandingAbsoluteTrackingPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetRawZeroPoseToStandingAbsoluteTrackingPose as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! (
                GetRawZeroPoseToStandingAbsoluteTrackingPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetSortedTrackedDeviceIndicesOfClass as * const _ as usize } ,
                120usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetSortedTrackedDeviceIndicesOfClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetTrackedDeviceActivityLevel as * const _ as usize } ,
                128usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetTrackedDeviceActivityLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) . ApplyTransform
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( ApplyTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetTrackedDeviceIndexForControllerRole as * const _ as usize }
                , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetTrackedDeviceIndexForControllerRole
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetControllerRoleForTrackedDeviceIndex as * const _ as usize }
                , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetControllerRoleForTrackedDeviceIndex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetTrackedDeviceClass as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetTrackedDeviceClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                IsTrackedDeviceConnected as * const _ as usize } , 168usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( IsTrackedDeviceConnected ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetBoolTrackedDeviceProperty as * const _ as usize } ,
                176usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetBoolTrackedDeviceProperty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetFloatTrackedDeviceProperty as * const _ as usize } ,
                184usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetFloatTrackedDeviceProperty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetInt32TrackedDeviceProperty as * const _ as usize } ,
                192usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetInt32TrackedDeviceProperty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetUint64TrackedDeviceProperty as * const _ as usize } ,
                200usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetUint64TrackedDeviceProperty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetMatrix34TrackedDeviceProperty as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetMatrix34TrackedDeviceProperty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetStringTrackedDeviceProperty as * const _ as usize } ,
                216usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetStringTrackedDeviceProperty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetPropErrorNameFromEnum as * const _ as usize } , 224usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetPropErrorNameFromEnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) . PollNextEvent
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( PollNextEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                PollNextEventWithPose as * const _ as usize } , 240usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( PollNextEventWithPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetEventTypeNameFromEnum as * const _ as usize } , 248usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetEventTypeNameFromEnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetHiddenAreaMesh as * const _ as usize } , 256usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetHiddenAreaMesh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetControllerState as * const _ as usize } , 264usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetControllerState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetControllerStateWithPose as * const _ as usize } , 272usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetControllerStateWithPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                TriggerHapticPulse as * const _ as usize } , 280usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( TriggerHapticPulse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetButtonIdNameFromEnum as * const _ as usize } , 288usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetButtonIdNameFromEnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                GetControllerAxisTypeNameFromEnum as * const _ as usize } ,
                296usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( GetControllerAxisTypeNameFromEnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                CaptureInputFocus as * const _ as usize } , 304usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( CaptureInputFocus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                ReleaseInputFocus as * const _ as usize } , 312usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( ReleaseInputFocus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                IsInputFocusCapturedByAnotherProcess as * const _ as usize } ,
                320usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( IsInputFocusCapturedByAnotherProcess )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                DriverDebugRequest as * const _ as usize } , 328usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( DriverDebugRequest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                PerformFirmwareUpdate as * const _ as usize } , 336usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( PerformFirmwareUpdate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                AcknowledgeQuit_Exiting as * const _ as usize } , 344usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( AcknowledgeQuit_Exiting ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSystem_FnTable ) ) .
                AcknowledgeQuit_UserPrompt as * const _ as usize } , 352usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSystem_FnTable )
                , "::" , stringify ! ( AcknowledgeQuit_UserPrompt ) ));
}
impl Clone for VR_IVRSystem_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRExtendedDisplay_FnTable {
    pub GetWindowBounds: ::std::option::Option<unsafe extern "C" fn(pnX:
                                                                        *mut i32,
                                                                    pnY:
                                                                        *mut i32,
                                                                    pnWidth:
                                                                        *mut u32,
                                                                    pnHeight:
                                                                        *mut u32)>,
    pub GetEyeOutputViewport: ::std::option::Option<unsafe extern "C" fn(eEye:
                                                                             EVREye,
                                                                         pnX:
                                                                             *mut u32,
                                                                         pnY:
                                                                             *mut u32,
                                                                         pnWidth:
                                                                             *mut u32,
                                                                         pnHeight:
                                                                             *mut u32)>,
    pub GetDXGIOutputInfo: ::std::option::Option<unsafe extern "C" fn(pnAdapterIndex:
                                                                          *mut i32,
                                                                      pnAdapterOutputIndex:
                                                                          *mut i32)>,
}
#[test]
fn bindgen_test_layout_VR_IVRExtendedDisplay_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRExtendedDisplay_FnTable>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VR_IVRExtendedDisplay_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRExtendedDisplay_FnTable>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VR_IVRExtendedDisplay_FnTable
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRExtendedDisplay_FnTable ) ) .
                GetWindowBounds as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRExtendedDisplay_FnTable ) , "::" , stringify ! (
                GetWindowBounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRExtendedDisplay_FnTable ) ) .
                GetEyeOutputViewport as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRExtendedDisplay_FnTable ) , "::" , stringify ! (
                GetEyeOutputViewport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRExtendedDisplay_FnTable ) ) .
                GetDXGIOutputInfo as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRExtendedDisplay_FnTable ) , "::" , stringify ! (
                GetDXGIOutputInfo ) ));
}
impl Clone for VR_IVRExtendedDisplay_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRTrackedCamera_FnTable {
    pub GetCameraErrorNameFromEnum: ::std::option::Option<unsafe extern "C" fn(eCameraError:
                                                                                   EVRTrackedCameraError)
                                                              ->
                                                                  *mut ::std::os::raw::c_char>,
    pub HasCamera: ::std::option::Option<unsafe extern "C" fn(nDeviceIndex:
                                                                  TrackedDeviceIndex_t,
                                                              pHasCamera:
                                                                  *mut bool)
                                             -> EVRTrackedCameraError>,
    pub GetCameraFrameSize: ::std::option::Option<unsafe extern "C" fn(nDeviceIndex:
                                                                           TrackedDeviceIndex_t,
                                                                       eFrameType:
                                                                           EVRTrackedCameraFrameType,
                                                                       pnWidth:
                                                                           *mut u32,
                                                                       pnHeight:
                                                                           *mut u32,
                                                                       pnFrameBufferSize:
                                                                           *mut u32)
                                                      ->
                                                          EVRTrackedCameraError>,
    pub GetCameraIntrinsics: ::std::option::Option<unsafe extern "C" fn(nDeviceIndex:
                                                                            TrackedDeviceIndex_t,
                                                                        eFrameType:
                                                                            EVRTrackedCameraFrameType,
                                                                        pFocalLength:
                                                                            *mut HmdVector2_t,
                                                                        pCenter:
                                                                            *mut HmdVector2_t)
                                                       ->
                                                           EVRTrackedCameraError>,
    pub GetCameraProjection: ::std::option::Option<unsafe extern "C" fn(nDeviceIndex:
                                                                            TrackedDeviceIndex_t,
                                                                        eFrameType:
                                                                            EVRTrackedCameraFrameType,
                                                                        flZNear:
                                                                            f32,
                                                                        flZFar:
                                                                            f32,
                                                                        pProjection:
                                                                            *mut HmdMatrix44_t)
                                                       ->
                                                           EVRTrackedCameraError>,
    pub AcquireVideoStreamingService: ::std::option::Option<unsafe extern "C" fn(nDeviceIndex:
                                                                                     TrackedDeviceIndex_t,
                                                                                 pHandle:
                                                                                     *mut TrackedCameraHandle_t)
                                                                ->
                                                                    EVRTrackedCameraError>,
    pub ReleaseVideoStreamingService: ::std::option::Option<unsafe extern "C" fn(hTrackedCamera:
                                                                                     TrackedCameraHandle_t)
                                                                ->
                                                                    EVRTrackedCameraError>,
    pub GetVideoStreamFrameBuffer: ::std::option::Option<unsafe extern "C" fn(hTrackedCamera:
                                                                                  TrackedCameraHandle_t,
                                                                              eFrameType:
                                                                                  EVRTrackedCameraFrameType,
                                                                              pFrameBuffer:
                                                                                  *mut ::std::os::raw::c_void,
                                                                              nFrameBufferSize:
                                                                                  u32,
                                                                              pFrameHeader:
                                                                                  *mut CameraVideoStreamFrameHeader_t,
                                                                              nFrameHeaderSize:
                                                                                  u32)
                                                             ->
                                                                 EVRTrackedCameraError>,
    pub GetVideoStreamTextureSize: ::std::option::Option<unsafe extern "C" fn(nDeviceIndex:
                                                                                  TrackedDeviceIndex_t,
                                                                              eFrameType:
                                                                                  EVRTrackedCameraFrameType,
                                                                              pTextureBounds:
                                                                                  *mut VRTextureBounds_t,
                                                                              pnWidth:
                                                                                  *mut u32,
                                                                              pnHeight:
                                                                                  *mut u32)
                                                             ->
                                                                 EVRTrackedCameraError>,
    pub GetVideoStreamTextureD3D11: ::std::option::Option<unsafe extern "C" fn(hTrackedCamera:
                                                                                   TrackedCameraHandle_t,
                                                                               eFrameType:
                                                                                   EVRTrackedCameraFrameType,
                                                                               pD3D11DeviceOrResource:
                                                                                   *mut ::std::os::raw::c_void,
                                                                               ppD3D11ShaderResourceView:
                                                                                   *mut *mut ::std::os::raw::c_void,
                                                                               pFrameHeader:
                                                                                   *mut CameraVideoStreamFrameHeader_t,
                                                                               nFrameHeaderSize:
                                                                                   u32)
                                                              ->
                                                                  EVRTrackedCameraError>,
    pub GetVideoStreamTextureGL: ::std::option::Option<unsafe extern "C" fn(hTrackedCamera:
                                                                                TrackedCameraHandle_t,
                                                                            eFrameType:
                                                                                EVRTrackedCameraFrameType,
                                                                            pglTextureId:
                                                                                *mut glUInt_t,
                                                                            pFrameHeader:
                                                                                *mut CameraVideoStreamFrameHeader_t,
                                                                            nFrameHeaderSize:
                                                                                u32)
                                                           ->
                                                               EVRTrackedCameraError>,
    pub ReleaseVideoStreamTextureGL: ::std::option::Option<unsafe extern "C" fn(hTrackedCamera:
                                                                                    TrackedCameraHandle_t,
                                                                                glTextureId:
                                                                                    glUInt_t)
                                                               ->
                                                                   EVRTrackedCameraError>,
}
#[test]
fn bindgen_test_layout_VR_IVRTrackedCamera_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRTrackedCamera_FnTable>() , 96usize
               , concat ! (
               "Size of: " , stringify ! ( VR_IVRTrackedCamera_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRTrackedCamera_FnTable>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VR_IVRTrackedCamera_FnTable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                GetCameraErrorNameFromEnum as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                GetCameraErrorNameFromEnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                HasCamera as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! ( HasCamera
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                GetCameraFrameSize as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                GetCameraFrameSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                GetCameraIntrinsics as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                GetCameraIntrinsics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                GetCameraProjection as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                GetCameraProjection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                AcquireVideoStreamingService as * const _ as usize } , 40usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                AcquireVideoStreamingService ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                ReleaseVideoStreamingService as * const _ as usize } , 48usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                ReleaseVideoStreamingService ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                GetVideoStreamFrameBuffer as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                GetVideoStreamFrameBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                GetVideoStreamTextureSize as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                GetVideoStreamTextureSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                GetVideoStreamTextureD3D11 as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                GetVideoStreamTextureD3D11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                GetVideoStreamTextureGL as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                GetVideoStreamTextureGL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRTrackedCamera_FnTable ) ) .
                ReleaseVideoStreamTextureGL as * const _ as usize } , 88usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRTrackedCamera_FnTable ) , "::" , stringify ! (
                ReleaseVideoStreamTextureGL ) ));
}
impl Clone for VR_IVRTrackedCamera_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRApplications_FnTable {
    pub AddApplicationManifest: ::std::option::Option<unsafe extern "C" fn(pchApplicationManifestFullPath:
                                                                               *mut ::std::os::raw::c_char,
                                                                           bTemporary:
                                                                               bool)
                                                          ->
                                                              EVRApplicationError>,
    pub RemoveApplicationManifest: ::std::option::Option<unsafe extern "C" fn(pchApplicationManifestFullPath:
                                                                                  *mut ::std::os::raw::c_char)
                                                             ->
                                                                 EVRApplicationError>,
    pub IsApplicationInstalled: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                               *mut ::std::os::raw::c_char)
                                                          -> bool>,
    pub GetApplicationCount: ::std::option::Option<unsafe extern "C" fn()
                                                       -> u32>,
    pub GetApplicationKeyByIndex: ::std::option::Option<unsafe extern "C" fn(unApplicationIndex:
                                                                                 u32,
                                                                             pchAppKeyBuffer:
                                                                                 *mut ::std::os::raw::c_char,
                                                                             unAppKeyBufferLen:
                                                                                 u32)
                                                            ->
                                                                EVRApplicationError>,
    pub GetApplicationKeyByProcessId: ::std::option::Option<unsafe extern "C" fn(unProcessId:
                                                                                     u32,
                                                                                 pchAppKeyBuffer:
                                                                                     *mut ::std::os::raw::c_char,
                                                                                 unAppKeyBufferLen:
                                                                                     u32)
                                                                ->
                                                                    EVRApplicationError>,
    pub LaunchApplication: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                          *mut ::std::os::raw::c_char)
                                                     -> EVRApplicationError>,
    pub LaunchTemplateApplication: ::std::option::Option<unsafe extern "C" fn(pchTemplateAppKey:
                                                                                  *mut ::std::os::raw::c_char,
                                                                              pchNewAppKey:
                                                                                  *mut ::std::os::raw::c_char,
                                                                              pKeys:
                                                                                  *mut AppOverrideKeys_t,
                                                                              unKeys:
                                                                                  u32)
                                                             ->
                                                                 EVRApplicationError>,
    pub LaunchApplicationFromMimeType: ::std::option::Option<unsafe extern "C" fn(pchMimeType:
                                                                                      *mut ::std::os::raw::c_char,
                                                                                  pchArgs:
                                                                                      *mut ::std::os::raw::c_char)
                                                                 ->
                                                                     EVRApplicationError>,
    pub LaunchDashboardOverlay: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                               *mut ::std::os::raw::c_char)
                                                          ->
                                                              EVRApplicationError>,
    pub CancelApplicationLaunch: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                                *mut ::std::os::raw::c_char)
                                                           -> bool>,
    pub IdentifyApplication: ::std::option::Option<unsafe extern "C" fn(unProcessId:
                                                                            u32,
                                                                        pchAppKey:
                                                                            *mut ::std::os::raw::c_char)
                                                       ->
                                                           EVRApplicationError>,
    pub GetApplicationProcessId: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                                *mut ::std::os::raw::c_char)
                                                           -> u32>,
    pub GetApplicationsErrorNameFromEnum: ::std::option::Option<unsafe extern "C" fn(error:
                                                                                         EVRApplicationError)
                                                                    ->
                                                                        *mut ::std::os::raw::c_char>,
    pub GetApplicationPropertyString: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                                     *mut ::std::os::raw::c_char,
                                                                                 eProperty:
                                                                                     EVRApplicationProperty,
                                                                                 pchPropertyValueBuffer:
                                                                                     *mut ::std::os::raw::c_char,
                                                                                 unPropertyValueBufferLen:
                                                                                     u32,
                                                                                 peError:
                                                                                     *mut EVRApplicationError)
                                                                -> u32>,
    pub GetApplicationPropertyBool: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                                   *mut ::std::os::raw::c_char,
                                                                               eProperty:
                                                                                   EVRApplicationProperty,
                                                                               peError:
                                                                                   *mut EVRApplicationError)
                                                              -> bool>,
    pub GetApplicationPropertyUint64: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                                     *mut ::std::os::raw::c_char,
                                                                                 eProperty:
                                                                                     EVRApplicationProperty,
                                                                                 peError:
                                                                                     *mut EVRApplicationError)
                                                                -> u64>,
    pub SetApplicationAutoLaunch: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                                 *mut ::std::os::raw::c_char,
                                                                             bAutoLaunch:
                                                                                 bool)
                                                            ->
                                                                EVRApplicationError>,
    pub GetApplicationAutoLaunch: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                                 *mut ::std::os::raw::c_char)
                                                            -> bool>,
    pub SetDefaultApplicationForMimeType: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                                         *mut ::std::os::raw::c_char,
                                                                                     pchMimeType:
                                                                                         *mut ::std::os::raw::c_char)
                                                                    ->
                                                                        EVRApplicationError>,
    pub GetDefaultApplicationForMimeType: ::std::option::Option<unsafe extern "C" fn(pchMimeType:
                                                                                         *mut ::std::os::raw::c_char,
                                                                                     pchAppKeyBuffer:
                                                                                         *mut ::std::os::raw::c_char,
                                                                                     unAppKeyBufferLen:
                                                                                         u32)
                                                                    -> bool>,
    pub GetApplicationSupportedMimeTypes: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                                         *mut ::std::os::raw::c_char,
                                                                                     pchMimeTypesBuffer:
                                                                                         *mut ::std::os::raw::c_char,
                                                                                     unMimeTypesBuffer:
                                                                                         u32)
                                                                    -> bool>,
    pub GetApplicationsThatSupportMimeType: ::std::option::Option<unsafe extern "C" fn(pchMimeType:
                                                                                           *mut ::std::os::raw::c_char,
                                                                                       pchAppKeysThatSupportBuffer:
                                                                                           *mut ::std::os::raw::c_char,
                                                                                       unAppKeysThatSupportBuffer:
                                                                                           u32)
                                                                      -> u32>,
    pub GetApplicationLaunchArguments: ::std::option::Option<unsafe extern "C" fn(unHandle:
                                                                                      u32,
                                                                                  pchArgs:
                                                                                      *mut ::std::os::raw::c_char,
                                                                                  unArgs:
                                                                                      u32)
                                                                 -> u32>,
    pub GetStartingApplication: ::std::option::Option<unsafe extern "C" fn(pchAppKeyBuffer:
                                                                               *mut ::std::os::raw::c_char,
                                                                           unAppKeyBufferLen:
                                                                               u32)
                                                          ->
                                                              EVRApplicationError>,
    pub GetTransitionState: ::std::option::Option<unsafe extern "C" fn()
                                                      ->
                                                          EVRApplicationTransitionState>,
    pub PerformApplicationPrelaunchCheck: ::std::option::Option<unsafe extern "C" fn(pchAppKey:
                                                                                         *mut ::std::os::raw::c_char)
                                                                    ->
                                                                        EVRApplicationError>,
    pub GetApplicationsTransitionStateNameFromEnum: ::std::option::Option<unsafe extern "C" fn(state:
                                                                                                   EVRApplicationTransitionState)
                                                                              ->
                                                                                  *mut ::std::os::raw::c_char>,
    pub IsQuitUserPromptRequested: ::std::option::Option<unsafe extern "C" fn()
                                                             -> bool>,
    pub LaunchInternalProcess: ::std::option::Option<unsafe extern "C" fn(pchBinaryPath:
                                                                              *mut ::std::os::raw::c_char,
                                                                          pchArguments:
                                                                              *mut ::std::os::raw::c_char,
                                                                          pchWorkingDirectory:
                                                                              *mut ::std::os::raw::c_char)
                                                         ->
                                                             EVRApplicationError>,
    pub GetCurrentSceneProcessId: ::std::option::Option<unsafe extern "C" fn()
                                                            -> u32>,
}
#[test]
fn bindgen_test_layout_VR_IVRApplications_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRApplications_FnTable>() , 248usize
               , concat ! (
               "Size of: " , stringify ! ( VR_IVRApplications_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRApplications_FnTable>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VR_IVRApplications_FnTable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                AddApplicationManifest as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                AddApplicationManifest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                RemoveApplicationManifest as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                RemoveApplicationManifest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                IsApplicationInstalled as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                IsApplicationInstalled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationCount as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationKeyByIndex as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationKeyByIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationKeyByProcessId as * const _ as usize } , 40usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationKeyByProcessId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                LaunchApplication as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                LaunchApplication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                LaunchTemplateApplication as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                LaunchTemplateApplication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                LaunchApplicationFromMimeType as * const _ as usize } ,
                64usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                LaunchApplicationFromMimeType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                LaunchDashboardOverlay as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                LaunchDashboardOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                CancelApplicationLaunch as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                CancelApplicationLaunch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                IdentifyApplication as * const _ as usize } , 88usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                IdentifyApplication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationProcessId as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationProcessId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationsErrorNameFromEnum as * const _ as usize } ,
                104usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationsErrorNameFromEnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationPropertyString as * const _ as usize } ,
                112usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationPropertyString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationPropertyBool as * const _ as usize } , 120usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationPropertyBool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationPropertyUint64 as * const _ as usize } ,
                128usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationPropertyUint64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                SetApplicationAutoLaunch as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                SetApplicationAutoLaunch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationAutoLaunch as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationAutoLaunch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                SetDefaultApplicationForMimeType as * const _ as usize } ,
                152usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                SetDefaultApplicationForMimeType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetDefaultApplicationForMimeType as * const _ as usize } ,
                160usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetDefaultApplicationForMimeType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationSupportedMimeTypes as * const _ as usize } ,
                168usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationSupportedMimeTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationsThatSupportMimeType as * const _ as usize } ,
                176usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationsThatSupportMimeType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationLaunchArguments as * const _ as usize } ,
                184usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationLaunchArguments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetStartingApplication as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetStartingApplication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetTransitionState as * const _ as usize } , 200usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetTransitionState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                PerformApplicationPrelaunchCheck as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                PerformApplicationPrelaunchCheck ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetApplicationsTransitionStateNameFromEnum as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetApplicationsTransitionStateNameFromEnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                IsQuitUserPromptRequested as * const _ as usize } , 224usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                IsQuitUserPromptRequested ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                LaunchInternalProcess as * const _ as usize } , 232usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                LaunchInternalProcess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRApplications_FnTable ) ) .
                GetCurrentSceneProcessId as * const _ as usize } , 240usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRApplications_FnTable ) , "::" , stringify ! (
                GetCurrentSceneProcessId ) ));
}
impl Clone for VR_IVRApplications_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRChaperone_FnTable {
    pub GetCalibrationState: ::std::option::Option<unsafe extern "C" fn()
                                                       ->
                                                           ChaperoneCalibrationState>,
    pub GetPlayAreaSize: ::std::option::Option<unsafe extern "C" fn(pSizeX:
                                                                        *mut f32,
                                                                    pSizeZ:
                                                                        *mut f32)
                                                   -> bool>,
    pub GetPlayAreaRect: ::std::option::Option<unsafe extern "C" fn(rect:
                                                                        *mut HmdQuad_t)
                                                   -> bool>,
    pub ReloadInfo: ::std::option::Option<unsafe extern "C" fn()>,
    pub SetSceneColor: ::std::option::Option<unsafe extern "C" fn(color:
                                                                      HmdColor_t)>,
    pub GetBoundsColor: ::std::option::Option<unsafe extern "C" fn(pOutputColorArray:
                                                                       *mut HmdColor_t,
                                                                   nNumOutputColors:
                                                                       ::std::os::raw::c_int,
                                                                   flCollisionBoundsFadeDistance:
                                                                       f32,
                                                                   pOutputCameraColor:
                                                                       *mut HmdColor_t)>,
    pub AreBoundsVisible: ::std::option::Option<unsafe extern "C" fn()
                                                    -> bool>,
    pub ForceBoundsVisible: ::std::option::Option<unsafe extern "C" fn(bForce:
                                                                           bool)>,
}
#[test]
fn bindgen_test_layout_VR_IVRChaperone_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRChaperone_FnTable>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( VR_IVRChaperone_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRChaperone_FnTable>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VR_IVRChaperone_FnTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperone_FnTable ) ) .
                GetCalibrationState as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRChaperone_FnTable
                ) , "::" , stringify ! ( GetCalibrationState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperone_FnTable ) ) .
                GetPlayAreaSize as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRChaperone_FnTable
                ) , "::" , stringify ! ( GetPlayAreaSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperone_FnTable ) ) .
                GetPlayAreaRect as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRChaperone_FnTable
                ) , "::" , stringify ! ( GetPlayAreaRect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperone_FnTable ) ) . ReloadInfo
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRChaperone_FnTable
                ) , "::" , stringify ! ( ReloadInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperone_FnTable ) ) .
                SetSceneColor as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRChaperone_FnTable
                ) , "::" , stringify ! ( SetSceneColor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperone_FnTable ) ) .
                GetBoundsColor as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRChaperone_FnTable
                ) , "::" , stringify ! ( GetBoundsColor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperone_FnTable ) ) .
                AreBoundsVisible as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVRChaperone_FnTable
                ) , "::" , stringify ! ( AreBoundsVisible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperone_FnTable ) ) .
                ForceBoundsVisible as * const _ as usize } , 56usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRChaperone_FnTable
                ) , "::" , stringify ! ( ForceBoundsVisible ) ));
}
impl Clone for VR_IVRChaperone_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRChaperoneSetup_FnTable {
    pub CommitWorkingCopy: ::std::option::Option<unsafe extern "C" fn(configFile:
                                                                          EChaperoneConfigFile)
                                                     -> bool>,
    pub RevertWorkingCopy: ::std::option::Option<unsafe extern "C" fn()>,
    pub GetWorkingPlayAreaSize: ::std::option::Option<unsafe extern "C" fn(pSizeX:
                                                                               *mut f32,
                                                                           pSizeZ:
                                                                               *mut f32)
                                                          -> bool>,
    pub GetWorkingPlayAreaRect: ::std::option::Option<unsafe extern "C" fn(rect:
                                                                               *mut HmdQuad_t)
                                                          -> bool>,
    pub GetWorkingCollisionBoundsInfo: ::std::option::Option<unsafe extern "C" fn(pQuadsBuffer:
                                                                                      *mut HmdQuad_t,
                                                                                  punQuadsCount:
                                                                                      *mut u32)
                                                                 -> bool>,
    pub GetLiveCollisionBoundsInfo: ::std::option::Option<unsafe extern "C" fn(pQuadsBuffer:
                                                                                   *mut HmdQuad_t,
                                                                               punQuadsCount:
                                                                                   *mut u32)
                                                              -> bool>,
    pub GetWorkingSeatedZeroPoseToRawTrackingPose: ::std::option::Option<unsafe extern "C" fn(pmatSeatedZeroPoseToRawTrackingPose:
                                                                                                  *mut HmdMatrix34_t)
                                                                             ->
                                                                                 bool>,
    pub GetWorkingStandingZeroPoseToRawTrackingPose: ::std::option::Option<unsafe extern "C" fn(pmatStandingZeroPoseToRawTrackingPose:
                                                                                                    *mut HmdMatrix34_t)
                                                                               ->
                                                                                   bool>,
    pub SetWorkingPlayAreaSize: ::std::option::Option<unsafe extern "C" fn(sizeX:
                                                                               f32,
                                                                           sizeZ:
                                                                               f32)>,
    pub SetWorkingCollisionBoundsInfo: ::std::option::Option<unsafe extern "C" fn(pQuadsBuffer:
                                                                                      *mut HmdQuad_t,
                                                                                  unQuadsCount:
                                                                                      u32)>,
    pub SetWorkingSeatedZeroPoseToRawTrackingPose: ::std::option::Option<unsafe extern "C" fn(pMatSeatedZeroPoseToRawTrackingPose:
                                                                                                  *mut HmdMatrix34_t)>,
    pub SetWorkingStandingZeroPoseToRawTrackingPose: ::std::option::Option<unsafe extern "C" fn(pMatStandingZeroPoseToRawTrackingPose:
                                                                                                    *mut HmdMatrix34_t)>,
    pub ReloadFromDisk: ::std::option::Option<unsafe extern "C" fn(configFile:
                                                                       EChaperoneConfigFile)>,
    pub GetLiveSeatedZeroPoseToRawTrackingPose: ::std::option::Option<unsafe extern "C" fn(pmatSeatedZeroPoseToRawTrackingPose:
                                                                                               *mut HmdMatrix34_t)
                                                                          ->
                                                                              bool>,
    pub SetWorkingCollisionBoundsTagsInfo: ::std::option::Option<unsafe extern "C" fn(pTagsBuffer:
                                                                                          *mut u8,
                                                                                      unTagCount:
                                                                                          u32)>,
    pub GetLiveCollisionBoundsTagsInfo: ::std::option::Option<unsafe extern "C" fn(pTagsBuffer:
                                                                                       *mut u8,
                                                                                   punTagCount:
                                                                                       *mut u32)
                                                                  -> bool>,
    pub SetWorkingPhysicalBoundsInfo: ::std::option::Option<unsafe extern "C" fn(pQuadsBuffer:
                                                                                     *mut HmdQuad_t,
                                                                                 unQuadsCount:
                                                                                     u32)
                                                                -> bool>,
    pub GetLivePhysicalBoundsInfo: ::std::option::Option<unsafe extern "C" fn(pQuadsBuffer:
                                                                                  *mut HmdQuad_t,
                                                                              punQuadsCount:
                                                                                  *mut u32)
                                                             -> bool>,
    pub ExportLiveToBuffer: ::std::option::Option<unsafe extern "C" fn(pBuffer:
                                                                           *mut ::std::os::raw::c_char,
                                                                       pnBufferLength:
                                                                           *mut u32)
                                                      -> bool>,
    pub ImportFromBufferToWorking: ::std::option::Option<unsafe extern "C" fn(pBuffer:
                                                                                  *mut ::std::os::raw::c_char,
                                                                              nImportFlags:
                                                                                  u32)
                                                             -> bool>,
}
#[test]
fn bindgen_test_layout_VR_IVRChaperoneSetup_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRChaperoneSetup_FnTable>() ,
               160usize , concat ! (
               "Size of: " , stringify ! ( VR_IVRChaperoneSetup_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRChaperoneSetup_FnTable>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VR_IVRChaperoneSetup_FnTable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                CommitWorkingCopy as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                CommitWorkingCopy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                RevertWorkingCopy as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                RevertWorkingCopy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                GetWorkingPlayAreaSize as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                GetWorkingPlayAreaSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                GetWorkingPlayAreaRect as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                GetWorkingPlayAreaRect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                GetWorkingCollisionBoundsInfo as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                GetWorkingCollisionBoundsInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                GetLiveCollisionBoundsInfo as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                GetLiveCollisionBoundsInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                GetWorkingSeatedZeroPoseToRawTrackingPose as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                GetWorkingSeatedZeroPoseToRawTrackingPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                GetWorkingStandingZeroPoseToRawTrackingPose as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                GetWorkingStandingZeroPoseToRawTrackingPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                SetWorkingPlayAreaSize as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                SetWorkingPlayAreaSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                SetWorkingCollisionBoundsInfo as * const _ as usize } ,
                72usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                SetWorkingCollisionBoundsInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                SetWorkingSeatedZeroPoseToRawTrackingPose as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                SetWorkingSeatedZeroPoseToRawTrackingPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                SetWorkingStandingZeroPoseToRawTrackingPose as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                SetWorkingStandingZeroPoseToRawTrackingPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                ReloadFromDisk as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                ReloadFromDisk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                GetLiveSeatedZeroPoseToRawTrackingPose as * const _ as usize }
                , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                GetLiveSeatedZeroPoseToRawTrackingPose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                SetWorkingCollisionBoundsTagsInfo as * const _ as usize } ,
                112usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                SetWorkingCollisionBoundsTagsInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                GetLiveCollisionBoundsTagsInfo as * const _ as usize } ,
                120usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                GetLiveCollisionBoundsTagsInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                SetWorkingPhysicalBoundsInfo as * const _ as usize } ,
                128usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                SetWorkingPhysicalBoundsInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                GetLivePhysicalBoundsInfo as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                GetLivePhysicalBoundsInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                ExportLiveToBuffer as * const _ as usize } , 144usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                ExportLiveToBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRChaperoneSetup_FnTable ) ) .
                ImportFromBufferToWorking as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRChaperoneSetup_FnTable ) , "::" , stringify ! (
                ImportFromBufferToWorking ) ));
}
impl Clone for VR_IVRChaperoneSetup_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRCompositor_FnTable {
    pub SetTrackingSpace: ::std::option::Option<unsafe extern "C" fn(eOrigin:
                                                                         ETrackingUniverseOrigin)>,
    pub GetTrackingSpace: ::std::option::Option<unsafe extern "C" fn()
                                                    ->
                                                        ETrackingUniverseOrigin>,
    pub WaitGetPoses: ::std::option::Option<unsafe extern "C" fn(pRenderPoseArray:
                                                                     *mut TrackedDevicePose_t,
                                                                 unRenderPoseArrayCount:
                                                                     u32,
                                                                 pGamePoseArray:
                                                                     *mut TrackedDevicePose_t,
                                                                 unGamePoseArrayCount:
                                                                     u32)
                                                -> EVRCompositorError>,
    pub GetLastPoses: ::std::option::Option<unsafe extern "C" fn(pRenderPoseArray:
                                                                     *mut TrackedDevicePose_t,
                                                                 unRenderPoseArrayCount:
                                                                     u32,
                                                                 pGamePoseArray:
                                                                     *mut TrackedDevicePose_t,
                                                                 unGamePoseArrayCount:
                                                                     u32)
                                                -> EVRCompositorError>,
    pub GetLastPoseForTrackedDeviceIndex: ::std::option::Option<unsafe extern "C" fn(unDeviceIndex:
                                                                                         TrackedDeviceIndex_t,
                                                                                     pOutputPose:
                                                                                         *mut TrackedDevicePose_t,
                                                                                     pOutputGamePose:
                                                                                         *mut TrackedDevicePose_t)
                                                                    ->
                                                                        EVRCompositorError>,
    pub Submit: ::std::option::Option<unsafe extern "C" fn(eEye: EVREye,
                                                           pTexture:
                                                               *mut Texture_t,
                                                           pBounds:
                                                               *mut VRTextureBounds_t,
                                                           nSubmitFlags:
                                                               EVRSubmitFlags)
                                          -> EVRCompositorError>,
    pub ClearLastSubmittedFrame: ::std::option::Option<unsafe extern "C" fn()>,
    pub PostPresentHandoff: ::std::option::Option<unsafe extern "C" fn()>,
    pub GetFrameTiming: ::std::option::Option<unsafe extern "C" fn(pTiming:
                                                                       *mut Compositor_FrameTiming,
                                                                   unFramesAgo:
                                                                       u32)
                                                  -> bool>,
    pub GetFrameTimings: ::std::option::Option<unsafe extern "C" fn(pTiming:
                                                                        *mut Compositor_FrameTiming,
                                                                    nFrames:
                                                                        u32)
                                                   -> u32>,
    pub GetFrameTimeRemaining: ::std::option::Option<unsafe extern "C" fn()
                                                         -> f32>,
    pub GetCumulativeStats: ::std::option::Option<unsafe extern "C" fn(pStats:
                                                                           *mut Compositor_CumulativeStats,
                                                                       nStatsSizeInBytes:
                                                                           u32)>,
    pub FadeToColor: ::std::option::Option<unsafe extern "C" fn(fSeconds: f32,
                                                                fRed: f32,
                                                                fGreen: f32,
                                                                fBlue: f32,
                                                                fAlpha: f32,
                                                                bBackground:
                                                                    bool)>,
    pub GetCurrentFadeColor: ::std::option::Option<unsafe extern "C" fn(bBackground:
                                                                            bool)
                                                       -> HmdColor_t>,
    pub FadeGrid: ::std::option::Option<unsafe extern "C" fn(fSeconds: f32,
                                                             bFadeIn: bool)>,
    pub GetCurrentGridAlpha: ::std::option::Option<unsafe extern "C" fn()
                                                       -> f32>,
    pub SetSkyboxOverride: ::std::option::Option<unsafe extern "C" fn(pTextures:
                                                                          *mut Texture_t,
                                                                      unTextureCount:
                                                                          u32)
                                                     -> EVRCompositorError>,
    pub ClearSkyboxOverride: ::std::option::Option<unsafe extern "C" fn()>,
    pub CompositorBringToFront: ::std::option::Option<unsafe extern "C" fn()>,
    pub CompositorGoToBack: ::std::option::Option<unsafe extern "C" fn()>,
    pub CompositorQuit: ::std::option::Option<unsafe extern "C" fn()>,
    pub IsFullscreen: ::std::option::Option<unsafe extern "C" fn() -> bool>,
    pub GetCurrentSceneFocusProcess: ::std::option::Option<unsafe extern "C" fn()
                                                               -> u32>,
    pub GetLastFrameRenderer: ::std::option::Option<unsafe extern "C" fn()
                                                        -> u32>,
    pub CanRenderScene: ::std::option::Option<unsafe extern "C" fn() -> bool>,
    pub ShowMirrorWindow: ::std::option::Option<unsafe extern "C" fn()>,
    pub HideMirrorWindow: ::std::option::Option<unsafe extern "C" fn()>,
    pub IsMirrorWindowVisible: ::std::option::Option<unsafe extern "C" fn()
                                                         -> bool>,
    pub CompositorDumpImages: ::std::option::Option<unsafe extern "C" fn()>,
    pub ShouldAppRenderWithLowResources: ::std::option::Option<unsafe extern "C" fn()
                                                                   -> bool>,
    pub ForceInterleavedReprojectionOn: ::std::option::Option<unsafe extern "C" fn(bOverride:
                                                                                       bool)>,
    pub ForceReconnectProcess: ::std::option::Option<unsafe extern "C" fn()>,
    pub SuspendRendering: ::std::option::Option<unsafe extern "C" fn(bSuspend:
                                                                         bool)>,
    pub GetMirrorTextureD3D11: ::std::option::Option<unsafe extern "C" fn(eEye:
                                                                              EVREye,
                                                                          pD3D11DeviceOrResource:
                                                                              *mut ::std::os::raw::c_void,
                                                                          ppD3D11ShaderResourceView:
                                                                              *mut *mut ::std::os::raw::c_void)
                                                         ->
                                                             EVRCompositorError>,
    pub ReleaseMirrorTextureD3D11: ::std::option::Option<unsafe extern "C" fn(pD3D11ShaderResourceView:
                                                                                  *mut ::std::os::raw::c_void)>,
    pub GetMirrorTextureGL: ::std::option::Option<unsafe extern "C" fn(eEye:
                                                                           EVREye,
                                                                       pglTextureId:
                                                                           *mut glUInt_t,
                                                                       pglSharedTextureHandle:
                                                                           *mut glSharedTextureHandle_t)
                                                      -> EVRCompositorError>,
    pub ReleaseSharedGLTexture: ::std::option::Option<unsafe extern "C" fn(glTextureId:
                                                                               glUInt_t,
                                                                           glSharedTextureHandle:
                                                                               glSharedTextureHandle_t)
                                                          -> bool>,
    pub LockGLSharedTextureForAccess: ::std::option::Option<unsafe extern "C" fn(glSharedTextureHandle:
                                                                                     glSharedTextureHandle_t)>,
    pub UnlockGLSharedTextureForAccess: ::std::option::Option<unsafe extern "C" fn(glSharedTextureHandle:
                                                                                       glSharedTextureHandle_t)>,
    pub GetVulkanInstanceExtensionsRequired: ::std::option::Option<unsafe extern "C" fn(pchValue:
                                                                                            *mut ::std::os::raw::c_char,
                                                                                        unBufferSize:
                                                                                            u32)
                                                                       ->
                                                                           u32>,
    pub GetVulkanDeviceExtensionsRequired: ::std::option::Option<unsafe extern "C" fn(pPhysicalDevice:
                                                                                          *mut VkPhysicalDevice_T,
                                                                                      pchValue:
                                                                                          *mut ::std::os::raw::c_char,
                                                                                      unBufferSize:
                                                                                          u32)
                                                                     -> u32>,
}
#[test]
fn bindgen_test_layout_VR_IVRCompositor_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRCompositor_FnTable>() , 328usize ,
               concat ! (
               "Size of: " , stringify ! ( VR_IVRCompositor_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRCompositor_FnTable>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VR_IVRCompositor_FnTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                SetTrackingSpace as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                SetTrackingSpace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetTrackingSpace as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetTrackingSpace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                WaitGetPoses as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! ( WaitGetPoses
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetLastPoses as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! ( GetLastPoses
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetLastPoseForTrackedDeviceIndex as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetLastPoseForTrackedDeviceIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) . Submit as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! ( Submit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                ClearLastSubmittedFrame as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                ClearLastSubmittedFrame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                PostPresentHandoff as * const _ as usize } , 56usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                PostPresentHandoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetFrameTiming as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetFrameTiming ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetFrameTimings as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetFrameTimings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetFrameTimeRemaining as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetFrameTimeRemaining ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetCumulativeStats as * const _ as usize } , 88usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetCumulativeStats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                FadeToColor as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! ( FadeToColor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetCurrentFadeColor as * const _ as usize } , 104usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetCurrentFadeColor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) . FadeGrid
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! ( FadeGrid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetCurrentGridAlpha as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetCurrentGridAlpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                SetSkyboxOverride as * const _ as usize } , 128usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                SetSkyboxOverride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                ClearSkyboxOverride as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                ClearSkyboxOverride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                CompositorBringToFront as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                CompositorBringToFront ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                CompositorGoToBack as * const _ as usize } , 152usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                CompositorGoToBack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                CompositorQuit as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                CompositorQuit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                IsFullscreen as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! ( IsFullscreen
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetCurrentSceneFocusProcess as * const _ as usize } , 176usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetCurrentSceneFocusProcess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetLastFrameRenderer as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetLastFrameRenderer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                CanRenderScene as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                CanRenderScene ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                ShowMirrorWindow as * const _ as usize } , 200usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                ShowMirrorWindow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                HideMirrorWindow as * const _ as usize } , 208usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                HideMirrorWindow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                IsMirrorWindowVisible as * const _ as usize } , 216usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                IsMirrorWindowVisible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                CompositorDumpImages as * const _ as usize } , 224usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                CompositorDumpImages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                ShouldAppRenderWithLowResources as * const _ as usize } ,
                232usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                ShouldAppRenderWithLowResources ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                ForceInterleavedReprojectionOn as * const _ as usize } ,
                240usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                ForceInterleavedReprojectionOn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                ForceReconnectProcess as * const _ as usize } , 248usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                ForceReconnectProcess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                SuspendRendering as * const _ as usize } , 256usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                SuspendRendering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetMirrorTextureD3D11 as * const _ as usize } , 264usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetMirrorTextureD3D11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                ReleaseMirrorTextureD3D11 as * const _ as usize } , 272usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                ReleaseMirrorTextureD3D11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetMirrorTextureGL as * const _ as usize } , 280usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetMirrorTextureGL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                ReleaseSharedGLTexture as * const _ as usize } , 288usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                ReleaseSharedGLTexture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                LockGLSharedTextureForAccess as * const _ as usize } ,
                296usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                LockGLSharedTextureForAccess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                UnlockGLSharedTextureForAccess as * const _ as usize } ,
                304usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                UnlockGLSharedTextureForAccess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetVulkanInstanceExtensionsRequired as * const _ as usize } ,
                312usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetVulkanInstanceExtensionsRequired ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRCompositor_FnTable ) ) .
                GetVulkanDeviceExtensionsRequired as * const _ as usize } ,
                320usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRCompositor_FnTable ) , "::" , stringify ! (
                GetVulkanDeviceExtensionsRequired ) ));
}
impl Clone for VR_IVRCompositor_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVROverlay_FnTable {
    pub FindOverlay: ::std::option::Option<unsafe extern "C" fn(pchOverlayKey:
                                                                    *mut ::std::os::raw::c_char,
                                                                pOverlayHandle:
                                                                    *mut VROverlayHandle_t)
                                               -> EVROverlayError>,
    pub CreateOverlay: ::std::option::Option<unsafe extern "C" fn(pchOverlayKey:
                                                                      *mut ::std::os::raw::c_char,
                                                                  pchOverlayName:
                                                                      *mut ::std::os::raw::c_char,
                                                                  pOverlayHandle:
                                                                      *mut VROverlayHandle_t)
                                                 -> EVROverlayError>,
    pub DestroyOverlay: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                       VROverlayHandle_t)
                                                  -> EVROverlayError>,
    pub SetHighQualityOverlay: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                              VROverlayHandle_t)
                                                         -> EVROverlayError>,
    pub GetHighQualityOverlay: ::std::option::Option<unsafe extern "C" fn()
                                                         ->
                                                             VROverlayHandle_t>,
    pub GetOverlayKey: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                      VROverlayHandle_t,
                                                                  pchValue:
                                                                      *mut ::std::os::raw::c_char,
                                                                  unBufferSize:
                                                                      u32,
                                                                  pError:
                                                                      *mut EVROverlayError)
                                                 -> u32>,
    pub GetOverlayName: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                       VROverlayHandle_t,
                                                                   pchValue:
                                                                       *mut ::std::os::raw::c_char,
                                                                   unBufferSize:
                                                                       u32,
                                                                   pError:
                                                                       *mut EVROverlayError)
                                                  -> u32>,
    pub SetOverlayName: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                       VROverlayHandle_t,
                                                                   pchName:
                                                                       *mut ::std::os::raw::c_char)
                                                  -> EVROverlayError>,
    pub GetOverlayImageData: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                            VROverlayHandle_t,
                                                                        pvBuffer:
                                                                            *mut ::std::os::raw::c_void,
                                                                        unBufferSize:
                                                                            u32,
                                                                        punWidth:
                                                                            *mut u32,
                                                                        punHeight:
                                                                            *mut u32)
                                                       -> EVROverlayError>,
    pub GetOverlayErrorNameFromEnum: ::std::option::Option<unsafe extern "C" fn(error:
                                                                                    EVROverlayError)
                                                               ->
                                                                   *mut ::std::os::raw::c_char>,
    pub SetOverlayRenderingPid: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                               VROverlayHandle_t,
                                                                           unPID:
                                                                               u32)
                                                          -> EVROverlayError>,
    pub GetOverlayRenderingPid: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                               VROverlayHandle_t)
                                                          -> u32>,
    pub SetOverlayFlag: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                       VROverlayHandle_t,
                                                                   eOverlayFlag:
                                                                       VROverlayFlags,
                                                                   bEnabled:
                                                                       bool)
                                                  -> EVROverlayError>,
    pub GetOverlayFlag: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                       VROverlayHandle_t,
                                                                   eOverlayFlag:
                                                                       VROverlayFlags,
                                                                   pbEnabled:
                                                                       *mut bool)
                                                  -> EVROverlayError>,
    pub SetOverlayColor: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                        VROverlayHandle_t,
                                                                    fRed: f32,
                                                                    fGreen:
                                                                        f32,
                                                                    fBlue:
                                                                        f32)
                                                   -> EVROverlayError>,
    pub GetOverlayColor: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                        VROverlayHandle_t,
                                                                    pfRed:
                                                                        *mut f32,
                                                                    pfGreen:
                                                                        *mut f32,
                                                                    pfBlue:
                                                                        *mut f32)
                                                   -> EVROverlayError>,
    pub SetOverlayAlpha: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                        VROverlayHandle_t,
                                                                    fAlpha:
                                                                        f32)
                                                   -> EVROverlayError>,
    pub GetOverlayAlpha: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                        VROverlayHandle_t,
                                                                    pfAlpha:
                                                                        *mut f32)
                                                   -> EVROverlayError>,
    pub SetOverlayTexelAspect: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                              VROverlayHandle_t,
                                                                          fTexelAspect:
                                                                              f32)
                                                         -> EVROverlayError>,
    pub GetOverlayTexelAspect: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                              VROverlayHandle_t,
                                                                          pfTexelAspect:
                                                                              *mut f32)
                                                         -> EVROverlayError>,
    pub SetOverlaySortOrder: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                            VROverlayHandle_t,
                                                                        unSortOrder:
                                                                            u32)
                                                       -> EVROverlayError>,
    pub GetOverlaySortOrder: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                            VROverlayHandle_t,
                                                                        punSortOrder:
                                                                            *mut u32)
                                                       -> EVROverlayError>,
    pub SetOverlayWidthInMeters: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                VROverlayHandle_t,
                                                                            fWidthInMeters:
                                                                                f32)
                                                           ->
                                                               EVROverlayError>,
    pub GetOverlayWidthInMeters: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                VROverlayHandle_t,
                                                                            pfWidthInMeters:
                                                                                *mut f32)
                                                           ->
                                                               EVROverlayError>,
    pub SetOverlayAutoCurveDistanceRangeInMeters: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                                 VROverlayHandle_t,
                                                                                             fMinDistanceInMeters:
                                                                                                 f32,
                                                                                             fMaxDistanceInMeters:
                                                                                                 f32)
                                                                            ->
                                                                                EVROverlayError>,
    pub GetOverlayAutoCurveDistanceRangeInMeters: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                                 VROverlayHandle_t,
                                                                                             pfMinDistanceInMeters:
                                                                                                 *mut f32,
                                                                                             pfMaxDistanceInMeters:
                                                                                                 *mut f32)
                                                                            ->
                                                                                EVROverlayError>,
    pub SetOverlayTextureColorSpace: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                    VROverlayHandle_t,
                                                                                eTextureColorSpace:
                                                                                    EColorSpace)
                                                               ->
                                                                   EVROverlayError>,
    pub GetOverlayTextureColorSpace: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                    VROverlayHandle_t,
                                                                                peTextureColorSpace:
                                                                                    *mut EColorSpace)
                                                               ->
                                                                   EVROverlayError>,
    pub SetOverlayTextureBounds: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                VROverlayHandle_t,
                                                                            pOverlayTextureBounds:
                                                                                *mut VRTextureBounds_t)
                                                           ->
                                                               EVROverlayError>,
    pub GetOverlayTextureBounds: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                VROverlayHandle_t,
                                                                            pOverlayTextureBounds:
                                                                                *mut VRTextureBounds_t)
                                                           ->
                                                               EVROverlayError>,
    pub GetOverlayRenderModel: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                              VROverlayHandle_t,
                                                                          pchValue:
                                                                              *mut ::std::os::raw::c_char,
                                                                          unBufferSize:
                                                                              u32,
                                                                          pColor:
                                                                              *mut HmdColor_t,
                                                                          pError:
                                                                              *mut EVROverlayError)
                                                         -> u32>,
    pub SetOverlayRenderModel: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                              VROverlayHandle_t,
                                                                          pchRenderModel:
                                                                              *mut ::std::os::raw::c_char,
                                                                          pColor:
                                                                              *mut HmdColor_t)
                                                         -> EVROverlayError>,
    pub GetOverlayTransformType: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                VROverlayHandle_t,
                                                                            peTransformType:
                                                                                *mut VROverlayTransformType)
                                                           ->
                                                               EVROverlayError>,
    pub SetOverlayTransformAbsolute: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                    VROverlayHandle_t,
                                                                                eTrackingOrigin:
                                                                                    ETrackingUniverseOrigin,
                                                                                pmatTrackingOriginToOverlayTransform:
                                                                                    *mut HmdMatrix34_t)
                                                               ->
                                                                   EVROverlayError>,
    pub GetOverlayTransformAbsolute: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                    VROverlayHandle_t,
                                                                                peTrackingOrigin:
                                                                                    *mut ETrackingUniverseOrigin,
                                                                                pmatTrackingOriginToOverlayTransform:
                                                                                    *mut HmdMatrix34_t)
                                                               ->
                                                                   EVROverlayError>,
    pub SetOverlayTransformTrackedDeviceRelative: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                                 VROverlayHandle_t,
                                                                                             unTrackedDevice:
                                                                                                 TrackedDeviceIndex_t,
                                                                                             pmatTrackedDeviceToOverlayTransform:
                                                                                                 *mut HmdMatrix34_t)
                                                                            ->
                                                                                EVROverlayError>,
    pub GetOverlayTransformTrackedDeviceRelative: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                                 VROverlayHandle_t,
                                                                                             punTrackedDevice:
                                                                                                 *mut TrackedDeviceIndex_t,
                                                                                             pmatTrackedDeviceToOverlayTransform:
                                                                                                 *mut HmdMatrix34_t)
                                                                            ->
                                                                                EVROverlayError>,
    pub SetOverlayTransformTrackedDeviceComponent: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                                  VROverlayHandle_t,
                                                                                              unDeviceIndex:
                                                                                                  TrackedDeviceIndex_t,
                                                                                              pchComponentName:
                                                                                                  *mut ::std::os::raw::c_char)
                                                                             ->
                                                                                 EVROverlayError>,
    pub GetOverlayTransformTrackedDeviceComponent: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                                  VROverlayHandle_t,
                                                                                              punDeviceIndex:
                                                                                                  *mut TrackedDeviceIndex_t,
                                                                                              pchComponentName:
                                                                                                  *mut ::std::os::raw::c_char,
                                                                                              unComponentNameSize:
                                                                                                  u32)
                                                                             ->
                                                                                 EVROverlayError>,
    pub GetOverlayTransformOverlayRelative: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                           VROverlayHandle_t,
                                                                                       ulOverlayHandleParent:
                                                                                           *mut VROverlayHandle_t,
                                                                                       pmatParentOverlayToOverlayTransform:
                                                                                           *mut HmdMatrix34_t)
                                                                      ->
                                                                          EVROverlayError>,
    pub SetOverlayTransformOverlayRelative: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                           VROverlayHandle_t,
                                                                                       ulOverlayHandleParent:
                                                                                           VROverlayHandle_t,
                                                                                       pmatParentOverlayToOverlayTransform:
                                                                                           *mut HmdMatrix34_t)
                                                                      ->
                                                                          EVROverlayError>,
    pub ShowOverlay: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                    VROverlayHandle_t)
                                               -> EVROverlayError>,
    pub HideOverlay: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                    VROverlayHandle_t)
                                               -> EVROverlayError>,
    pub IsOverlayVisible: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                         VROverlayHandle_t)
                                                    -> bool>,
    pub GetTransformForOverlayCoordinates: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                          VROverlayHandle_t,
                                                                                      eTrackingOrigin:
                                                                                          ETrackingUniverseOrigin,
                                                                                      coordinatesInOverlay:
                                                                                          HmdVector2_t,
                                                                                      pmatTransform:
                                                                                          *mut HmdMatrix34_t)
                                                                     ->
                                                                         EVROverlayError>,
    pub PollNextOverlayEvent: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                             VROverlayHandle_t,
                                                                         pEvent:
                                                                             *mut VREvent_t,
                                                                         uncbVREvent:
                                                                             u32)
                                                        -> bool>,
    pub GetOverlayInputMethod: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                              VROverlayHandle_t,
                                                                          peInputMethod:
                                                                              *mut VROverlayInputMethod)
                                                         -> EVROverlayError>,
    pub SetOverlayInputMethod: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                              VROverlayHandle_t,
                                                                          eInputMethod:
                                                                              VROverlayInputMethod)
                                                         -> EVROverlayError>,
    pub GetOverlayMouseScale: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                             VROverlayHandle_t,
                                                                         pvecMouseScale:
                                                                             *mut HmdVector2_t)
                                                        -> EVROverlayError>,
    pub SetOverlayMouseScale: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                             VROverlayHandle_t,
                                                                         pvecMouseScale:
                                                                             *mut HmdVector2_t)
                                                        -> EVROverlayError>,
    pub ComputeOverlayIntersection: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                   VROverlayHandle_t,
                                                                               pParams:
                                                                                   *mut VROverlayIntersectionParams_t,
                                                                               pResults:
                                                                                   *mut VROverlayIntersectionResults_t)
                                                              -> bool>,
    pub HandleControllerOverlayInteractionAsMouse: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                                  VROverlayHandle_t,
                                                                                              unControllerDeviceIndex:
                                                                                                  TrackedDeviceIndex_t)
                                                                             ->
                                                                                 bool>,
    pub IsHoverTargetOverlay: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                             VROverlayHandle_t)
                                                        -> bool>,
    pub GetGamepadFocusOverlay: ::std::option::Option<unsafe extern "C" fn()
                                                          ->
                                                              VROverlayHandle_t>,
    pub SetGamepadFocusOverlay: ::std::option::Option<unsafe extern "C" fn(ulNewFocusOverlay:
                                                                               VROverlayHandle_t)
                                                          -> EVROverlayError>,
    pub SetOverlayNeighbor: ::std::option::Option<unsafe extern "C" fn(eDirection:
                                                                           EOverlayDirection,
                                                                       ulFrom:
                                                                           VROverlayHandle_t,
                                                                       ulTo:
                                                                           VROverlayHandle_t)
                                                      -> EVROverlayError>,
    pub MoveGamepadFocusToNeighbor: ::std::option::Option<unsafe extern "C" fn(eDirection:
                                                                                   EOverlayDirection,
                                                                               ulFrom:
                                                                                   VROverlayHandle_t)
                                                              ->
                                                                  EVROverlayError>,
    pub SetOverlayTexture: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                          VROverlayHandle_t,
                                                                      pTexture:
                                                                          *mut Texture_t)
                                                     -> EVROverlayError>,
    pub ClearOverlayTexture: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                            VROverlayHandle_t)
                                                       -> EVROverlayError>,
    pub SetOverlayRaw: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                      VROverlayHandle_t,
                                                                  pvBuffer:
                                                                      *mut ::std::os::raw::c_void,
                                                                  unWidth:
                                                                      u32,
                                                                  unHeight:
                                                                      u32,
                                                                  unDepth:
                                                                      u32)
                                                 -> EVROverlayError>,
    pub SetOverlayFromFile: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                           VROverlayHandle_t,
                                                                       pchFilePath:
                                                                           *mut ::std::os::raw::c_char)
                                                      -> EVROverlayError>,
    pub GetOverlayTexture: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                          VROverlayHandle_t,
                                                                      pNativeTextureHandle:
                                                                          *mut *mut ::std::os::raw::c_void,
                                                                      pNativeTextureRef:
                                                                          *mut ::std::os::raw::c_void,
                                                                      pWidth:
                                                                          *mut u32,
                                                                      pHeight:
                                                                          *mut u32,
                                                                      pNativeFormat:
                                                                          *mut u32,
                                                                      pAPIType:
                                                                          *mut ETextureType,
                                                                      pColorSpace:
                                                                          *mut EColorSpace,
                                                                      pTextureBounds:
                                                                          *mut VRTextureBounds_t)
                                                     -> EVROverlayError>,
    pub ReleaseNativeOverlayHandle: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                   VROverlayHandle_t,
                                                                               pNativeTextureHandle:
                                                                                   *mut ::std::os::raw::c_void)
                                                              ->
                                                                  EVROverlayError>,
    pub GetOverlayTextureSize: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                              VROverlayHandle_t,
                                                                          pWidth:
                                                                              *mut u32,
                                                                          pHeight:
                                                                              *mut u32)
                                                         -> EVROverlayError>,
    pub CreateDashboardOverlay: ::std::option::Option<unsafe extern "C" fn(pchOverlayKey:
                                                                               *mut ::std::os::raw::c_char,
                                                                           pchOverlayFriendlyName:
                                                                               *mut ::std::os::raw::c_char,
                                                                           pMainHandle:
                                                                               *mut VROverlayHandle_t,
                                                                           pThumbnailHandle:
                                                                               *mut VROverlayHandle_t)
                                                          -> EVROverlayError>,
    pub IsDashboardVisible: ::std::option::Option<unsafe extern "C" fn()
                                                      -> bool>,
    pub IsActiveDashboardOverlay: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                 VROverlayHandle_t)
                                                            -> bool>,
    pub SetDashboardOverlaySceneProcess: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                        VROverlayHandle_t,
                                                                                    unProcessId:
                                                                                        u32)
                                                                   ->
                                                                       EVROverlayError>,
    pub GetDashboardOverlaySceneProcess: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                        VROverlayHandle_t,
                                                                                    punProcessId:
                                                                                        *mut u32)
                                                                   ->
                                                                       EVROverlayError>,
    pub ShowDashboard: ::std::option::Option<unsafe extern "C" fn(pchOverlayToShow:
                                                                      *mut ::std::os::raw::c_char)>,
    pub GetPrimaryDashboardDevice: ::std::option::Option<unsafe extern "C" fn()
                                                             ->
                                                                 TrackedDeviceIndex_t>,
    pub ShowKeyboard: ::std::option::Option<unsafe extern "C" fn(eInputMode:
                                                                     EGamepadTextInputMode,
                                                                 eLineInputMode:
                                                                     EGamepadTextInputLineMode,
                                                                 pchDescription:
                                                                     *mut ::std::os::raw::c_char,
                                                                 unCharMax:
                                                                     u32,
                                                                 pchExistingText:
                                                                     *mut ::std::os::raw::c_char,
                                                                 bUseMinimalMode:
                                                                     bool,
                                                                 uUserValue:
                                                                     u64)
                                                -> EVROverlayError>,
    pub ShowKeyboardForOverlay: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                               VROverlayHandle_t,
                                                                           eInputMode:
                                                                               EGamepadTextInputMode,
                                                                           eLineInputMode:
                                                                               EGamepadTextInputLineMode,
                                                                           pchDescription:
                                                                               *mut ::std::os::raw::c_char,
                                                                           unCharMax:
                                                                               u32,
                                                                           pchExistingText:
                                                                               *mut ::std::os::raw::c_char,
                                                                           bUseMinimalMode:
                                                                               bool,
                                                                           uUserValue:
                                                                               u64)
                                                          -> EVROverlayError>,
    pub GetKeyboardText: ::std::option::Option<unsafe extern "C" fn(pchText:
                                                                        *mut ::std::os::raw::c_char,
                                                                    cchText:
                                                                        u32)
                                                   -> u32>,
    pub HideKeyboard: ::std::option::Option<unsafe extern "C" fn()>,
    pub SetKeyboardTransformAbsolute: ::std::option::Option<unsafe extern "C" fn(eTrackingOrigin:
                                                                                     ETrackingUniverseOrigin,
                                                                                 pmatTrackingOriginToKeyboardTransform:
                                                                                     *mut HmdMatrix34_t)>,
    pub SetKeyboardPositionForOverlay: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                      VROverlayHandle_t,
                                                                                  avoidRect:
                                                                                      HmdRect2_t)>,
    pub SetOverlayIntersectionMask: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                                   VROverlayHandle_t,
                                                                               pMaskPrimitives:
                                                                                   *mut VROverlayIntersectionMaskPrimitive_t,
                                                                               unNumMaskPrimitives:
                                                                                   u32,
                                                                               unPrimitiveSize:
                                                                                   u32)
                                                              ->
                                                                  EVROverlayError>,
    pub GetOverlayFlags: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                        VROverlayHandle_t,
                                                                    pFlags:
                                                                        *mut u32)
                                                   -> EVROverlayError>,
    pub ShowMessageOverlay: ::std::option::Option<unsafe extern "C" fn(pchText:
                                                                           *mut ::std::os::raw::c_char,
                                                                       pchCaption:
                                                                           *mut ::std::os::raw::c_char,
                                                                       pchButton0Text:
                                                                           *mut ::std::os::raw::c_char,
                                                                       pchButton1Text:
                                                                           *mut ::std::os::raw::c_char,
                                                                       pchButton2Text:
                                                                           *mut ::std::os::raw::c_char,
                                                                       pchButton3Text:
                                                                           *mut ::std::os::raw::c_char)
                                                      ->
                                                          VRMessageOverlayResponse>,
}
#[test]
fn bindgen_test_layout_VR_IVROverlay_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVROverlay_FnTable>() , 640usize ,
               concat ! ( "Size of: " , stringify ! ( VR_IVROverlay_FnTable )
               ));
    assert_eq! (::std::mem::align_of::<VR_IVROverlay_FnTable>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VR_IVROverlay_FnTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) . FindOverlay
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( FindOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) . CreateOverlay
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( CreateOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                DestroyOverlay as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( DestroyOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetHighQualityOverlay as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetHighQualityOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetHighQualityOverlay as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetHighQualityOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) . GetOverlayKey
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayName as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayName as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayImageData as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayImageData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayErrorNameFromEnum as * const _ as usize } , 72usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayErrorNameFromEnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayRenderingPid as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayRenderingPid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayRenderingPid as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayRenderingPid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayFlag as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayFlag as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayColor as * const _ as usize } , 112usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayColor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayColor as * const _ as usize } , 120usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayColor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayAlpha as * const _ as usize } , 128usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayAlpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayAlpha as * const _ as usize } , 136usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayAlpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayTexelAspect as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayTexelAspect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayTexelAspect as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayTexelAspect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlaySortOrder as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlaySortOrder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlaySortOrder as * const _ as usize } , 168usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlaySortOrder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayWidthInMeters as * const _ as usize } , 176usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayWidthInMeters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayWidthInMeters as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayWidthInMeters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayAutoCurveDistanceRangeInMeters as * const _ as usize
                } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! (
                SetOverlayAutoCurveDistanceRangeInMeters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayAutoCurveDistanceRangeInMeters as * const _ as usize
                } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! (
                GetOverlayAutoCurveDistanceRangeInMeters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayTextureColorSpace as * const _ as usize } , 208usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayTextureColorSpace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayTextureColorSpace as * const _ as usize } , 216usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayTextureColorSpace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayTextureBounds as * const _ as usize } , 224usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayTextureBounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayTextureBounds as * const _ as usize } , 232usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayTextureBounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayRenderModel as * const _ as usize } , 240usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayRenderModel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayRenderModel as * const _ as usize } , 248usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayRenderModel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayTransformType as * const _ as usize } , 256usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayTransformType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayTransformAbsolute as * const _ as usize } , 264usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayTransformAbsolute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayTransformAbsolute as * const _ as usize } , 272usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayTransformAbsolute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayTransformTrackedDeviceRelative as * const _ as usize
                } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! (
                SetOverlayTransformTrackedDeviceRelative ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayTransformTrackedDeviceRelative as * const _ as usize
                } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! (
                GetOverlayTransformTrackedDeviceRelative ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayTransformTrackedDeviceComponent as * const _ as
                usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! (
                SetOverlayTransformTrackedDeviceComponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayTransformTrackedDeviceComponent as * const _ as
                usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! (
                GetOverlayTransformTrackedDeviceComponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayTransformOverlayRelative as * const _ as usize } ,
                312usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayTransformOverlayRelative )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayTransformOverlayRelative as * const _ as usize } ,
                320usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayTransformOverlayRelative )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) . ShowOverlay
                as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( ShowOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) . HideOverlay
                as * const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( HideOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                IsOverlayVisible as * const _ as usize } , 344usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( IsOverlayVisible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetTransformForOverlayCoordinates as * const _ as usize } ,
                352usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetTransformForOverlayCoordinates ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                PollNextOverlayEvent as * const _ as usize } , 360usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( PollNextOverlayEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayInputMethod as * const _ as usize } , 368usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayInputMethod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayInputMethod as * const _ as usize } , 376usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayInputMethod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayMouseScale as * const _ as usize } , 384usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayMouseScale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayMouseScale as * const _ as usize } , 392usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayMouseScale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                ComputeOverlayIntersection as * const _ as usize } , 400usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( ComputeOverlayIntersection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                HandleControllerOverlayInteractionAsMouse as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! (
                HandleControllerOverlayInteractionAsMouse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                IsHoverTargetOverlay as * const _ as usize } , 416usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( IsHoverTargetOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetGamepadFocusOverlay as * const _ as usize } , 424usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetGamepadFocusOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetGamepadFocusOverlay as * const _ as usize } , 432usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetGamepadFocusOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayNeighbor as * const _ as usize } , 440usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayNeighbor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                MoveGamepadFocusToNeighbor as * const _ as usize } , 448usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( MoveGamepadFocusToNeighbor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayTexture as * const _ as usize } , 456usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayTexture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                ClearOverlayTexture as * const _ as usize } , 464usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( ClearOverlayTexture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) . SetOverlayRaw
                as * const _ as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayRaw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayFromFile as * const _ as usize } , 480usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayFromFile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayTexture as * const _ as usize } , 488usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayTexture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                ReleaseNativeOverlayHandle as * const _ as usize } , 496usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( ReleaseNativeOverlayHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayTextureSize as * const _ as usize } , 504usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayTextureSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                CreateDashboardOverlay as * const _ as usize } , 512usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( CreateDashboardOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                IsDashboardVisible as * const _ as usize } , 520usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( IsDashboardVisible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                IsActiveDashboardOverlay as * const _ as usize } , 528usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( IsActiveDashboardOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetDashboardOverlaySceneProcess as * const _ as usize } ,
                536usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetDashboardOverlaySceneProcess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetDashboardOverlaySceneProcess as * const _ as usize } ,
                544usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetDashboardOverlaySceneProcess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) . ShowDashboard
                as * const _ as usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( ShowDashboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetPrimaryDashboardDevice as * const _ as usize } , 560usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetPrimaryDashboardDevice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) . ShowKeyboard
                as * const _ as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( ShowKeyboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                ShowKeyboardForOverlay as * const _ as usize } , 576usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( ShowKeyboardForOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetKeyboardText as * const _ as usize } , 584usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetKeyboardText ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) . HideKeyboard
                as * const _ as usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( HideKeyboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetKeyboardTransformAbsolute as * const _ as usize } ,
                600usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetKeyboardTransformAbsolute ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetKeyboardPositionForOverlay as * const _ as usize } ,
                608usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetKeyboardPositionForOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                SetOverlayIntersectionMask as * const _ as usize } , 616usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( SetOverlayIntersectionMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                GetOverlayFlags as * const _ as usize } , 624usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( GetOverlayFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVROverlay_FnTable ) ) .
                ShowMessageOverlay as * const _ as usize } , 632usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVROverlay_FnTable )
                , "::" , stringify ! ( ShowMessageOverlay ) ));
}
impl Clone for VR_IVROverlay_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRRenderModels_FnTable {
    pub LoadRenderModel_Async: ::std::option::Option<unsafe extern "C" fn(pchRenderModelName:
                                                                              *mut ::std::os::raw::c_char,
                                                                          ppRenderModel:
                                                                              *mut *mut RenderModel_t)
                                                         ->
                                                             EVRRenderModelError>,
    pub FreeRenderModel: ::std::option::Option<unsafe extern "C" fn(pRenderModel:
                                                                        *mut RenderModel_t)>,
    pub LoadTexture_Async: ::std::option::Option<unsafe extern "C" fn(textureId:
                                                                          TextureID_t,
                                                                      ppTexture:
                                                                          *mut *mut RenderModel_TextureMap_t)
                                                     -> EVRRenderModelError>,
    pub FreeTexture: ::std::option::Option<unsafe extern "C" fn(pTexture:
                                                                    *mut RenderModel_TextureMap_t)>,
    pub LoadTextureD3D11_Async: ::std::option::Option<unsafe extern "C" fn(textureId:
                                                                               TextureID_t,
                                                                           pD3D11Device:
                                                                               *mut ::std::os::raw::c_void,
                                                                           ppD3D11Texture2D:
                                                                               *mut *mut ::std::os::raw::c_void)
                                                          ->
                                                              EVRRenderModelError>,
    pub LoadIntoTextureD3D11_Async: ::std::option::Option<unsafe extern "C" fn(textureId:
                                                                                   TextureID_t,
                                                                               pDstTexture:
                                                                                   *mut ::std::os::raw::c_void)
                                                              ->
                                                                  EVRRenderModelError>,
    pub FreeTextureD3D11: ::std::option::Option<unsafe extern "C" fn(pD3D11Texture2D:
                                                                         *mut ::std::os::raw::c_void)>,
    pub GetRenderModelName: ::std::option::Option<unsafe extern "C" fn(unRenderModelIndex:
                                                                           u32,
                                                                       pchRenderModelName:
                                                                           *mut ::std::os::raw::c_char,
                                                                       unRenderModelNameLen:
                                                                           u32)
                                                      -> u32>,
    pub GetRenderModelCount: ::std::option::Option<unsafe extern "C" fn()
                                                       -> u32>,
    pub GetComponentCount: ::std::option::Option<unsafe extern "C" fn(pchRenderModelName:
                                                                          *mut ::std::os::raw::c_char)
                                                     -> u32>,
    pub GetComponentName: ::std::option::Option<unsafe extern "C" fn(pchRenderModelName:
                                                                         *mut ::std::os::raw::c_char,
                                                                     unComponentIndex:
                                                                         u32,
                                                                     pchComponentName:
                                                                         *mut ::std::os::raw::c_char,
                                                                     unComponentNameLen:
                                                                         u32)
                                                    -> u32>,
    pub GetComponentButtonMask: ::std::option::Option<unsafe extern "C" fn(pchRenderModelName:
                                                                               *mut ::std::os::raw::c_char,
                                                                           pchComponentName:
                                                                               *mut ::std::os::raw::c_char)
                                                          -> u64>,
    pub GetComponentRenderModelName: ::std::option::Option<unsafe extern "C" fn(pchRenderModelName:
                                                                                    *mut ::std::os::raw::c_char,
                                                                                pchComponentName:
                                                                                    *mut ::std::os::raw::c_char,
                                                                                pchComponentRenderModelName:
                                                                                    *mut ::std::os::raw::c_char,
                                                                                unComponentRenderModelNameLen:
                                                                                    u32)
                                                               -> u32>,
    pub GetComponentState: ::std::option::Option<unsafe extern "C" fn(pchRenderModelName:
                                                                          *mut ::std::os::raw::c_char,
                                                                      pchComponentName:
                                                                          *mut ::std::os::raw::c_char,
                                                                      pControllerState:
                                                                          *mut VRControllerState_t,
                                                                      pState:
                                                                          *mut RenderModel_ControllerMode_State_t,
                                                                      pComponentState:
                                                                          *mut RenderModel_ComponentState_t)
                                                     -> bool>,
    pub RenderModelHasComponent: ::std::option::Option<unsafe extern "C" fn(pchRenderModelName:
                                                                                *mut ::std::os::raw::c_char,
                                                                            pchComponentName:
                                                                                *mut ::std::os::raw::c_char)
                                                           -> bool>,
    pub GetRenderModelThumbnailURL: ::std::option::Option<unsafe extern "C" fn(pchRenderModelName:
                                                                                   *mut ::std::os::raw::c_char,
                                                                               pchThumbnailURL:
                                                                                   *mut ::std::os::raw::c_char,
                                                                               unThumbnailURLLen:
                                                                                   u32,
                                                                               peError:
                                                                                   *mut EVRRenderModelError)
                                                              -> u32>,
    pub GetRenderModelOriginalPath: ::std::option::Option<unsafe extern "C" fn(pchRenderModelName:
                                                                                   *mut ::std::os::raw::c_char,
                                                                               pchOriginalPath:
                                                                                   *mut ::std::os::raw::c_char,
                                                                               unOriginalPathLen:
                                                                                   u32,
                                                                               peError:
                                                                                   *mut EVRRenderModelError)
                                                              -> u32>,
    pub GetRenderModelErrorNameFromEnum: ::std::option::Option<unsafe extern "C" fn(error:
                                                                                        EVRRenderModelError)
                                                                   ->
                                                                       *mut ::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_VR_IVRRenderModels_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRRenderModels_FnTable>() , 144usize
               , concat ! (
               "Size of: " , stringify ! ( VR_IVRRenderModels_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRRenderModels_FnTable>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VR_IVRRenderModels_FnTable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                LoadRenderModel_Async as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                LoadRenderModel_Async ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                FreeRenderModel as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                FreeRenderModel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                LoadTexture_Async as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                LoadTexture_Async ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                FreeTexture as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                FreeTexture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                LoadTextureD3D11_Async as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                LoadTextureD3D11_Async ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                LoadIntoTextureD3D11_Async as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                LoadIntoTextureD3D11_Async ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                FreeTextureD3D11 as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                FreeTextureD3D11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                GetRenderModelName as * const _ as usize } , 56usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                GetRenderModelName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                GetRenderModelCount as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                GetRenderModelCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                GetComponentCount as * const _ as usize } , 72usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                GetComponentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                GetComponentName as * const _ as usize } , 80usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                GetComponentName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                GetComponentButtonMask as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                GetComponentButtonMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                GetComponentRenderModelName as * const _ as usize } , 96usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                GetComponentRenderModelName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                GetComponentState as * const _ as usize } , 104usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                GetComponentState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                RenderModelHasComponent as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                RenderModelHasComponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                GetRenderModelThumbnailURL as * const _ as usize } , 120usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                GetRenderModelThumbnailURL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                GetRenderModelOriginalPath as * const _ as usize } , 128usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                GetRenderModelOriginalPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRRenderModels_FnTable ) ) .
                GetRenderModelErrorNameFromEnum as * const _ as usize } ,
                136usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRRenderModels_FnTable ) , "::" , stringify ! (
                GetRenderModelErrorNameFromEnum ) ));
}
impl Clone for VR_IVRRenderModels_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRNotifications_FnTable {
    pub CreateNotification: ::std::option::Option<unsafe extern "C" fn(ulOverlayHandle:
                                                                           VROverlayHandle_t,
                                                                       ulUserValue:
                                                                           u64,
                                                                       type_:
                                                                           EVRNotificationType,
                                                                       pchText:
                                                                           *mut ::std::os::raw::c_char,
                                                                       style:
                                                                           EVRNotificationStyle,
                                                                       pImage:
                                                                           *mut NotificationBitmap_t,
                                                                       pNotificationId:
                                                                           *mut VRNotificationId)
                                                      ->
                                                          EVRNotificationError>,
    pub RemoveNotification: ::std::option::Option<unsafe extern "C" fn(notificationId:
                                                                           VRNotificationId)
                                                      ->
                                                          EVRNotificationError>,
}
#[test]
fn bindgen_test_layout_VR_IVRNotifications_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRNotifications_FnTable>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( VR_IVRNotifications_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRNotifications_FnTable>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VR_IVRNotifications_FnTable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRNotifications_FnTable ) ) .
                CreateNotification as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRNotifications_FnTable ) , "::" , stringify ! (
                CreateNotification ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRNotifications_FnTable ) ) .
                RemoveNotification as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRNotifications_FnTable ) , "::" , stringify ! (
                RemoveNotification ) ));
}
impl Clone for VR_IVRNotifications_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRSettings_FnTable {
    pub GetSettingsErrorNameFromEnum: ::std::option::Option<unsafe extern "C" fn(eError:
                                                                                     EVRSettingsError)
                                                                ->
                                                                    *mut ::std::os::raw::c_char>,
    pub Sync: ::std::option::Option<unsafe extern "C" fn(bForce: bool,
                                                         peError:
                                                             *mut EVRSettingsError)
                                        -> bool>,
    pub SetBool: ::std::option::Option<unsafe extern "C" fn(pchSection:
                                                                *mut ::std::os::raw::c_char,
                                                            pchSettingsKey:
                                                                *mut ::std::os::raw::c_char,
                                                            bValue: bool,
                                                            peError:
                                                                *mut EVRSettingsError)>,
    pub SetInt32: ::std::option::Option<unsafe extern "C" fn(pchSection:
                                                                 *mut ::std::os::raw::c_char,
                                                             pchSettingsKey:
                                                                 *mut ::std::os::raw::c_char,
                                                             nValue: i32,
                                                             peError:
                                                                 *mut EVRSettingsError)>,
    pub SetFloat: ::std::option::Option<unsafe extern "C" fn(pchSection:
                                                                 *mut ::std::os::raw::c_char,
                                                             pchSettingsKey:
                                                                 *mut ::std::os::raw::c_char,
                                                             flValue: f32,
                                                             peError:
                                                                 *mut EVRSettingsError)>,
    pub SetString: ::std::option::Option<unsafe extern "C" fn(pchSection:
                                                                  *mut ::std::os::raw::c_char,
                                                              pchSettingsKey:
                                                                  *mut ::std::os::raw::c_char,
                                                              pchValue:
                                                                  *mut ::std::os::raw::c_char,
                                                              peError:
                                                                  *mut EVRSettingsError)>,
    pub GetBool: ::std::option::Option<unsafe extern "C" fn(pchSection:
                                                                *mut ::std::os::raw::c_char,
                                                            pchSettingsKey:
                                                                *mut ::std::os::raw::c_char,
                                                            peError:
                                                                *mut EVRSettingsError)
                                           -> bool>,
    pub GetInt32: ::std::option::Option<unsafe extern "C" fn(pchSection:
                                                                 *mut ::std::os::raw::c_char,
                                                             pchSettingsKey:
                                                                 *mut ::std::os::raw::c_char,
                                                             peError:
                                                                 *mut EVRSettingsError)
                                            -> i32>,
    pub GetFloat: ::std::option::Option<unsafe extern "C" fn(pchSection:
                                                                 *mut ::std::os::raw::c_char,
                                                             pchSettingsKey:
                                                                 *mut ::std::os::raw::c_char,
                                                             peError:
                                                                 *mut EVRSettingsError)
                                            -> f32>,
    pub GetString: ::std::option::Option<unsafe extern "C" fn(pchSection:
                                                                  *mut ::std::os::raw::c_char,
                                                              pchSettingsKey:
                                                                  *mut ::std::os::raw::c_char,
                                                              pchValue:
                                                                  *mut ::std::os::raw::c_char,
                                                              unValueLen: u32,
                                                              peError:
                                                                  *mut EVRSettingsError)>,
    pub RemoveSection: ::std::option::Option<unsafe extern "C" fn(pchSection:
                                                                      *mut ::std::os::raw::c_char,
                                                                  peError:
                                                                      *mut EVRSettingsError)>,
    pub RemoveKeyInSection: ::std::option::Option<unsafe extern "C" fn(pchSection:
                                                                           *mut ::std::os::raw::c_char,
                                                                       pchSettingsKey:
                                                                           *mut ::std::os::raw::c_char,
                                                                       peError:
                                                                           *mut EVRSettingsError)>,
}
#[test]
fn bindgen_test_layout_VR_IVRSettings_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRSettings_FnTable>() , 96usize ,
               concat ! ( "Size of: " , stringify ! ( VR_IVRSettings_FnTable )
               ));
    assert_eq! (::std::mem::align_of::<VR_IVRSettings_FnTable>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VR_IVRSettings_FnTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) .
                GetSettingsErrorNameFromEnum as * const _ as usize } , 0usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( GetSettingsErrorNameFromEnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) . Sync as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( Sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) . SetBool as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( SetBool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) . SetInt32 as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( SetInt32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) . SetFloat as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( SetFloat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) . SetString as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( SetString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) . GetBool as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( GetBool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) . GetInt32 as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( GetInt32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) . GetFloat as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( GetFloat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) . GetString as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( GetString ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) .
                RemoveSection as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( RemoveSection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRSettings_FnTable ) ) .
                RemoveKeyInSection as * const _ as usize } , 88usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRSettings_FnTable
                ) , "::" , stringify ! ( RemoveKeyInSection ) ));
}
impl Clone for VR_IVRSettings_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRScreenshots_FnTable {
    pub RequestScreenshot: ::std::option::Option<unsafe extern "C" fn(pOutScreenshotHandle:
                                                                          *mut ScreenshotHandle_t,
                                                                      type_:
                                                                          EVRScreenshotType,
                                                                      pchPreviewFilename:
                                                                          *mut ::std::os::raw::c_char,
                                                                      pchVRFilename:
                                                                          *mut ::std::os::raw::c_char)
                                                     -> EVRScreenshotError>,
    pub HookScreenshot: ::std::option::Option<unsafe extern "C" fn(pSupportedTypes:
                                                                       *mut EVRScreenshotType,
                                                                   numTypes:
                                                                       ::std::os::raw::c_int)
                                                  -> EVRScreenshotError>,
    pub GetScreenshotPropertyType: ::std::option::Option<unsafe extern "C" fn(screenshotHandle:
                                                                                  ScreenshotHandle_t,
                                                                              pError:
                                                                                  *mut EVRScreenshotError)
                                                             ->
                                                                 EVRScreenshotType>,
    pub GetScreenshotPropertyFilename: ::std::option::Option<unsafe extern "C" fn(screenshotHandle:
                                                                                      ScreenshotHandle_t,
                                                                                  filenameType:
                                                                                      EVRScreenshotPropertyFilenames,
                                                                                  pchFilename:
                                                                                      *mut ::std::os::raw::c_char,
                                                                                  cchFilename:
                                                                                      u32,
                                                                                  pError:
                                                                                      *mut EVRScreenshotError)
                                                                 -> u32>,
    pub UpdateScreenshotProgress: ::std::option::Option<unsafe extern "C" fn(screenshotHandle:
                                                                                 ScreenshotHandle_t,
                                                                             flProgress:
                                                                                 f32)
                                                            ->
                                                                EVRScreenshotError>,
    pub TakeStereoScreenshot: ::std::option::Option<unsafe extern "C" fn(pOutScreenshotHandle:
                                                                             *mut ScreenshotHandle_t,
                                                                         pchPreviewFilename:
                                                                             *mut ::std::os::raw::c_char,
                                                                         pchVRFilename:
                                                                             *mut ::std::os::raw::c_char)
                                                        ->
                                                            EVRScreenshotError>,
    pub SubmitScreenshot: ::std::option::Option<unsafe extern "C" fn(screenshotHandle:
                                                                         ScreenshotHandle_t,
                                                                     type_:
                                                                         EVRScreenshotType,
                                                                     pchSourcePreviewFilename:
                                                                         *mut ::std::os::raw::c_char,
                                                                     pchSourceVRFilename:
                                                                         *mut ::std::os::raw::c_char)
                                                    -> EVRScreenshotError>,
}
#[test]
fn bindgen_test_layout_VR_IVRScreenshots_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRScreenshots_FnTable>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( VR_IVRScreenshots_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRScreenshots_FnTable>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VR_IVRScreenshots_FnTable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRScreenshots_FnTable ) ) .
                RequestScreenshot as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRScreenshots_FnTable ) , "::" , stringify ! (
                RequestScreenshot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRScreenshots_FnTable ) ) .
                HookScreenshot as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRScreenshots_FnTable ) , "::" , stringify ! (
                HookScreenshot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRScreenshots_FnTable ) ) .
                GetScreenshotPropertyType as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRScreenshots_FnTable ) , "::" , stringify ! (
                GetScreenshotPropertyType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRScreenshots_FnTable ) ) .
                GetScreenshotPropertyFilename as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRScreenshots_FnTable ) , "::" , stringify ! (
                GetScreenshotPropertyFilename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRScreenshots_FnTable ) ) .
                UpdateScreenshotProgress as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRScreenshots_FnTable ) , "::" , stringify ! (
                UpdateScreenshotProgress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRScreenshots_FnTable ) ) .
                TakeStereoScreenshot as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRScreenshots_FnTable ) , "::" , stringify ! (
                TakeStereoScreenshot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRScreenshots_FnTable ) ) .
                SubmitScreenshot as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VR_IVRScreenshots_FnTable ) , "::" , stringify ! (
                SubmitScreenshot ) ));
}
impl Clone for VR_IVRScreenshots_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRResources_FnTable {
    pub LoadSharedResource: ::std::option::Option<unsafe extern "C" fn(pchResourceName:
                                                                           *mut ::std::os::raw::c_char,
                                                                       pchBuffer:
                                                                           *mut ::std::os::raw::c_char,
                                                                       unBufferLen:
                                                                           u32)
                                                      -> u32>,
    pub GetResourceFullPath: ::std::option::Option<unsafe extern "C" fn(pchResourceName:
                                                                            *mut ::std::os::raw::c_char,
                                                                        pchResourceTypeDirectory:
                                                                            *mut ::std::os::raw::c_char,
                                                                        pchPathBuffer:
                                                                            *mut ::std::os::raw::c_char,
                                                                        unBufferLen:
                                                                            u32)
                                                       -> u32>,
}
#[test]
fn bindgen_test_layout_VR_IVRResources_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRResources_FnTable>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( VR_IVRResources_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRResources_FnTable>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VR_IVRResources_FnTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRResources_FnTable ) ) .
                LoadSharedResource as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( VR_IVRResources_FnTable
                ) , "::" , stringify ! ( LoadSharedResource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRResources_FnTable ) ) .
                GetResourceFullPath as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VR_IVRResources_FnTable
                ) , "::" , stringify ! ( GetResourceFullPath ) ));
}
impl Clone for VR_IVRResources_FnTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VR_IVRDriverManager_FnTable {
    pub GetDriverCount: ::std::option::Option<unsafe extern "C" fn() -> u32>,
    pub GetDriverName: ::std::option::Option<unsafe extern "C" fn(nDriver:
                                                                      DriverId_t,
                                                                  pchValue:
                                                                      *mut ::std::os::raw::c_char,
                                                                  unBufferSize:
                                                                      u32)
                                                 -> u32>,
}
#[test]
fn bindgen_test_layout_VR_IVRDriverManager_FnTable() {
    assert_eq!(::std::mem::size_of::<VR_IVRDriverManager_FnTable>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( VR_IVRDriverManager_FnTable ) ));
    assert_eq! (::std::mem::align_of::<VR_IVRDriverManager_FnTable>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VR_IVRDriverManager_FnTable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRDriverManager_FnTable ) ) .
                GetDriverCount as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRDriverManager_FnTable ) , "::" , stringify ! (
                GetDriverCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VR_IVRDriverManager_FnTable ) ) .
                GetDriverName as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VR_IVRDriverManager_FnTable ) , "::" , stringify ! (
                GetDriverName ) ));
}
impl Clone for VR_IVRDriverManager_FnTable {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn VR_InitInternal(peError: *mut EVRInitError,
                           eType: EVRApplicationType) -> isize;
}
extern "C" {
    pub fn VR_ShutdownInternal();
}
extern "C" {
    pub fn VR_IsHmdPresent() -> bool;
}
extern "C" {
    pub fn VR_GetGenericInterface(pchInterfaceVersion:
                                      *const ::std::os::raw::c_char,
                                  peError: *mut EVRInitError) -> isize;
}
extern "C" {
    pub fn VR_IsRuntimeInstalled() -> bool;
}
extern "C" {
    pub fn VR_GetVRInitErrorAsSymbol(error: EVRInitError)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VR_GetVRInitErrorAsEnglishDescription(error: EVRInitError)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VR_IsInterfaceVersionValid(pchInterfaceVersion:
                                          *const ::std::os::raw::c_char)
     -> bool;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VREvent_Keyboard_t_real {
    pub cNewInput: [::std::os::raw::c_char; 8usize],
    pub uUserValue: u64,
}
#[test]
fn bindgen_test_layout_VREvent_Keyboard_t_real() {
    assert_eq!(::std::mem::size_of::<VREvent_Keyboard_t_real>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( VREvent_Keyboard_t_real ) ));
    assert_eq! (::std::mem::align_of::<VREvent_Keyboard_t_real>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VREvent_Keyboard_t_real ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Keyboard_t_real ) ) . cNewInput
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Keyboard_t_real
                ) , "::" , stringify ! ( cNewInput ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VREvent_Keyboard_t_real ) ) . uUserValue
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VREvent_Keyboard_t_real
                ) , "::" , stringify ! ( uUserValue ) ));
}
impl Clone for VREvent_Keyboard_t_real {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDevice_T {
    pub _address: u8,
}
impl Clone for VkDevice_T {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDevice_T {
    pub _address: u8,
}
impl Clone for VkPhysicalDevice_T {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkInstance_T {
    pub _address: u8,
}
impl Clone for VkInstance_T {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkQueue_T {
    pub _address: u8,
}
impl Clone for VkQueue_T {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ID3D12Resource {
    pub _address: u8,
}
impl Clone for ID3D12Resource {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ID3D12CommandQueue {
    pub _address: u8,
}
impl Clone for ID3D12CommandQueue {
    fn clone(&self) -> Self { *self }
}
